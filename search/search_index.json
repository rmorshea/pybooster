{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyBooster","text":"<p>Dependency injection without the boilerplate.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install -U pybooster\n</code></pre>"},{"location":"#at-a-glance","title":"At a Glance","text":"<p>Getting started with PyBooster involves a few steps:</p> <ol> <li>Define a provider function for a    dependency.</li> <li>Add an injector to a function that will use that dependency.</li> <li>Active a solution and call the dependent function in it.</li> </ol> <p>The example below injects a <code>sqlite3.Connection</code> into a function that executes a query:</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n\n\n@injector.function\ndef query_database(query: str, *, conn: sqlite3.Connection = required) -&gt; None:\n    conn.execute(query)\n\n\nwith solution(sqlite_connection.bind(\":memory:\")):\n    query_database(\"CREATE TABLE example (id INTEGER PRIMARY KEY)\")\n</code></pre> <p>This works by inspecting the type hints of the provider <code>sqlite_connection</code> to see that it produces a <code>sqlite3.Connection</code>. Simarly, the signature of the dependant function <code>query_database</code> is inspected to see that it requires a <code>sqlite3.Connection</code>. At that point, when <code>query_database</code> is called it checks to see if there's a <code>sqlite3.Connection</code> provider in the current soltion and, if so, injects it into the function.</p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#solutions","title":"Solutions","text":"<p>In order to inject a set of dependencies PyBooster must resolve the execution order their providers. That execution order is determined by performing a topological sort on the dependency graph that gets saved as a \"solution\". You can declare one using the <code>solution</code> context manager.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef alice_provider() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\n@injector.function\ndef get_message(*, recipient: Recipient = required) -&gt; str:\n    return f\"Hello, {recipient}!\"\n\n\nwith solution(alice_provider):\n    # alice is available to inject as a recipient\n    assert get_message() == \"Hello, Alice!\"\n</code></pre>"},{"location":"concepts/#nesting-solutions","title":"Nesting Solutions","text":"<p>You can override a dependency's provider by declaring a new solution for it:</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef alice_provider() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\n@provider.function\ndef bob_provider() -&gt; Recipient:\n    return Recipient(\"Bob\")\n\n\n@injector.function\ndef get_recipient(*, recipient: Recipient = required) -&gt; str:\n    return recipient\n\n\nwith solution(alice_provider):\n    assert get_recipient() == \"Alice\"\n    with solution(bob_provider):\n        assert get_recipient() == \"Bob\"\n    assert get_recipient() == \"Alice\"\n</code></pre>"},{"location":"concepts/#injectors","title":"Injectors","text":"<p>Injectors are used to supply a set of dependencies to a function.</p>"},{"location":"concepts/#decorator-injectors","title":"Decorator Injectors","text":"<p>PyBooster supplies a set of decorators that can be added to functions in order to inject dependencies into them. Dependencies for a decorated function are declared as keyword-only arguments with a type annotation and a default value of <code>required</code>.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import required\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@injector.function\ndef get_message(*, recipient: Recipient = required) -&gt; str:\n    return f\"Hello, {recipient}!\"\n</code></pre> <p>Warning</p> <p>Don't forget to add the <code>required</code> default value. Without it, PyBooster will not know that the argument is a dependency that needs to be injected.</p> <p>In order for a value to be injected you'll need to solve the depen</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef recipient_provider() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\n@injector.function\ndef get_message(*, recipient: Recipient = required) -&gt; str:\n    return f\"Hello, {recipient}!\"\n\n\nwith solution(recipient_provider):\n    assert get_message() == \"Hello, Alice!\"\n</code></pre> <p>PyBooster supports decorators for the following types of functions or methods:</p> <ul> <li>injector.function</li> <li>injector.asyncfunction</li> <li>injector.iterator</li> <li>injector.asynciterator</li> <li>injector.contextmanager</li> <li>injector.asynccontextmanager</li> </ul>"},{"location":"concepts/#overwrite-parameters","title":"Overwrite Parameters","text":"<p>You can pass values to a required parameter of a function with an injector decorator. The value will be passed as-is to the function and be used when other providers are called to fulfill the function's remaining dependencies:</p> <pre><code>from dataclasses import dataclass\nfrom typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nUserId = NewType(\"UserId\", int)\n\n\n@dataclass\nclass Profile:\n    name: str\n    bio: str\n\n\nDB = {\n    1: Profile(name=\"Alice\", bio=\"Alice's bio\"),\n    2: Profile(name=\"Bob\", bio=\"Bob's bio\"),\n}\n\n\n@provider.function\ndef user_id_provider() -&gt; UserId:\n    return UserId(1)\n\n\n@provider.function\ndef profile_provider(*, user_id: UserId = required) -&gt; Profile:\n    return DB[user_id]\n\n\n@injector.function\ndef get_profile_summary(\n    *, user_id: UserId = required, profile: Profile = required\n) -&gt; str:\n    return f\"#{user_id} {profile.name}: {profile.bio}\"\n\n\nwith solution(user_id_provider, profile_provider):\n    assert get_profile_summary() == \"#1 Alice: Alice's bio\"\n    assert get_profile_summary(user_id=UserId(2)) == \"#2 Bob: Bob's bio\"\n</code></pre>"},{"location":"concepts/#current-injector","title":"Current Injector","text":"<p>You can access the current value of a dependency using the <code>current</code> context manager.</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import solution\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@provider.function\ndef auth_provider() -&gt; Auth:\n    return Auth(username=\"alice\", password=\"EGwVEo3y9E\")\n\n\nwith solution(auth_provider):\n    with injector.current(Auth) as auth:\n        assert auth.username == \"alice\"\n        assert auth.password == \"EGwVEo3y9E\"\n</code></pre> <p>The value yielded by the context manager will also be shared across all injections for the duration of the context.</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@provider.function\ndef auth() -&gt; Auth:\n    return Auth(username=\"alice\", password=\"EGwVEo3y9E\")\n\n\n@injector.function\ndef get_auth(*, auth: Auth = required) -&gt; Auth:\n    return auth\n\n\nwith solution(auth):\n\n    assert get_auth() is not get_auth()\n\n    with injector.current(Auth) as auth:\n        assert auth is get_auth()\n        assert get_auth() is get_auth()\n</code></pre>"},{"location":"concepts/#overwrite-injector","title":"Overwrite Injector","text":"<p>You can overwrite the current values of dependencies by using the <code>overwrite</code> context manager. Pass a mapping of dependency types to thir new values to establish them for the duration of the context.</p> <pre><code>from dataclasses import dataclass\nfrom typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nUserId = NewType(\"UserId\", int)\n\n\n@dataclass\nclass Profile:\n    name: str\n    bio: str\n\n\nDB = {\n    1: Profile(name=\"Alice\", bio=\"Alice's bio\"),\n    2: Profile(name=\"Bob\", bio=\"Bob's bio\"),\n}\n\n\n@provider.function\ndef user_id_provider() -&gt; UserId:\n    return UserId(1)\n\n\n@provider.function\ndef profile_provider(*, user_id: UserId = required) -&gt; Profile:\n    return DB[user_id]\n\n\n@injector.function\ndef get_profile_summary(\n    *, user_id: UserId = required, profile: Profile = required\n) -&gt; str:\n    return f\"#{user_id} {profile.name}: {profile.bio}\"\n\n\nwith solution(user_id_provider, profile_provider):\n    assert get_profile_summary() == \"#1 Alice: Alice's bio\"\n    with injector.overwrite({UserId: UserId(2)}):\n        assert get_profile_summary() == \"#2 Bob: Bob's bio\"\n</code></pre>"},{"location":"concepts/#providers","title":"Providers","text":"<p>A provider is a function that creates or yields a dependency. What providers are available for, and thus what dependencies can be injected are determined by whether they were included in the current solution.</p>"},{"location":"concepts/#sync-providers","title":"Sync Providers","text":"<p>Sync providers can either be functions the return a dependency's value:</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import provider\n\n\n@dataclass\nclass Config:\n    app_name: str\n    app_version: int\n    debug_mode: bool\n\n\n@provider.function\ndef config_provider() -&gt; Config:\n    return Config(app_name=\"MyApp\", app_version=1, debug_mode=True)\n</code></pre> <p>Or iterators that yield the dependency's value. Iterators are useful when you have resources that need to be cleaned up when the dependency's value is no longer in use.</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import provider\n\n\n@provider.iterator\ndef sqlite_connection() -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(\"example.db\") as conn:\n        yield conn\n</code></pre>"},{"location":"concepts/#async-providers","title":"Async Providers","text":"<p>Async providers can either be a coroutine function that returns a dependency's value:</p> <pre><code>from asyncio import sleep\nfrom dataclasses import dataclass\n\nfrom pybooster import provider\n\n\n@dataclass\nclass Config:\n    app_name: str\n    app_version: int\n    debug_mode: bool\n\n\n@provider.asyncfunction\nasync def async_config_provider() -&gt; Config:\n    await sleep(1)  # Do some async work here...\n    return Config(app_name=\"MyApp\", app_version=1, debug_mode=True)\n</code></pre> <p>Or async iterators that yield the dependency's value. Async iterators are useful when you have resources that need to be cleaned up when the dependency's value is no longer in use.</p> <pre><code>from asyncio import StreamReader\nfrom asyncio import open_connection\nfrom typing import AsyncIterator\n\nfrom pybooster import provider\n\n\n@provider.asynciterator\nasync def example_reader() -&gt; AsyncIterator[StreamReader]:\n    reader, writer = await open_connection(\"example.com\", 80)\n    writer.write(b\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\")\n    await writer.drain()\n    try:\n        yield reader\n    finally:\n        writer.close()\n        await writer.wait_closed()\n</code></pre> <p>Async providers are executed concurrently where possible in the current solution.</p>"},{"location":"concepts/#generic-providers","title":"Generic Providers","text":"<p>You can use a single provider to supply multiple dependencies by narrowing the return type if it's a base class, union, <code>Any</code>, or includes a <code>TypeVar</code>. This is done using square brackets to annotate the exact concrete type that the provider will supply when solving. So, in the case you have a provider that loads json data from a file you could annotate its return type as <code>Any</code> but narrow the type to <code>ConfigDict</code> before declaring a solution:</p> <pre><code>import json\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import Any\nfrom typing import TypedDict\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n\n@provider.function\ndef json_provider(path: str | Path) -&gt; Any:\n    with Path(path).open() as f:\n        return json.load(f)\n\n\nclass ConfigDict(TypedDict):\n    app_name: str\n    app_version: int\n    debug_mode: bool\n\n\n@injector.function\ndef get_config(*, config: ConfigDict = required) -&gt; ConfigDict:\n    return config\n\n\ntempfile = NamedTemporaryFile()\njson_file = Path(tempfile.name)\njson_file.write_text(\n    '{\"app_name\": \"MyApp\", \"app_version\": 1, \"debug_mode\": true}'\n)\n\nwith solution(json_provider[ConfigDict].bind(json_file)):\n    assert get_config() == {\n        \"app_name\": \"MyApp\",\n        \"app_version\": 1,\n        \"debug_mode\": True,\n    }\n</code></pre> <p>Since concrete types for <code>TypeVar</code>s cannot be automatically inferred from the arguments passed to the provider. You must always narrow the return type (as shown above) or pass a <code>provides</code> inference function to the <code>@provider</code> decorator to specify how to figure out the concrete type. This function should take all the non-dependency arguments of the provider and return the concrete type. In the example below the provider is generic on the <code>cls: type[T]</code> argument so the <code>provides</code> inference function will just return that:</p> <pre><code>import json\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import TypeVar\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n\n@dataclass\nclass Config:\n    app_name: str\n    app_version: int\n    debug_mode: bool\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\nT = TypeVar(\"T\")\n\n\n@provider.function(provides=lambda cls, *a, **kw: cls)\ndef config_file_provider(cls: type[T], path: str | Path) -&gt; T:\n    with Path(path).open() as f:\n        return cls(**json.load(f))\n\n\n@injector.function\ndef get_config(*, config: Config = required) -&gt; Config:\n    return config\n\n\ntempfile = NamedTemporaryFile()\njson_file = Path(tempfile.name)\njson_file.write_text(\n    '{\"app_name\": \"MyApp\", \"app_version\": 1, \"debug_mode\": true}'\n)\n\nwith solution(config_file_provider.bind(Config, json_file)):\n    assert get_config() == Config(\n        app_name=\"MyApp\", app_version=1, debug_mode=True\n    )\n</code></pre> <p>Tip</p> <p>This approach also works great for a provider that has <code>overload</code> implementations.</p>"},{"location":"concepts/#singleton-providers","title":"Singleton Providers","text":"<p>To provide a single static value as a dependency, you can use the <code>provider.singleton</code> function. This is useful when you have a value that doesn't need to be computed or cleaned up.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@injector.function\ndef get_message(*, recipient: Recipient = required) -&gt; str:\n    return f\"Hello, {recipient}!\"\n\n\nwith solution(provider.singleton(Recipient, \"Alice\")):\n    assert get_message() == \"Hello, Alice!\"\n</code></pre>"},{"location":"concepts/#parameterizing-providers","title":"Parameterizing Providers","text":"<p>You can pass additional arguments to a provider by adding parameters to a provider function signature that are not dependencies:</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import provider\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n</code></pre> <p>These parameters can be supplied when solving using the <code>bind</code> method:</p> <pre><code>with solution(sqlite_connection.bind(\":memory:\")):\n    ...\n</code></pre> <p>You can also declare these parameters as dependencies by making them keyword-only, annotating them with the desired type, and setting the default value to <code>required</code>.</p> <pre><code>import os\nimport sqlite3\nfrom typing import Iterator\nfrom typing import NewType\n\nfrom pybooster import provider\nfrom pybooster import required\n\nDatabase = NewType(\"DatabasePath\", str)\n\n\n@provider.function\ndef sqlite_database() -&gt; Database:\n    return Database(os.environ.get(\"SQLITE_DATABASE\", \":memory:\"))\n\n\n@provider.iterator\ndef sqlite_connection(\n    *, database: Database = required\n) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n</code></pre>"},{"location":"concepts/#mixing-syncasync","title":"Mixing Sync/Async","text":"<p>You can define both sync and async providers for the same dependency. When running in an async context, PyBooster will prefer async providers over sync providers.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@provider.function\ndef sync_auth_provider() -&gt; Auth:\n    return Auth(username=\"sync-user\", password=\"sync-pass\")\n\n\n@provider.asyncfunction\nasync def async_auth_provider() -&gt; Auth:\n    await asyncio.sleep(0)  # Do some async work here...\n    return Auth(username=\"async-user\", password=\"async-pass\")\n\n\n@injector.function\ndef sync_get_auth(*, auth: Auth = required) -&gt; str:\n    return f\"{auth.username}:{auth.password}\"\n\n\n@injector.asyncfunction\nasync def async_get_auth(*, auth: Auth = required) -&gt; str:\n    return f\"{auth.username}:{auth.password}\"\n\n\nwith solution(sync_auth_provider, async_auth_provider):\n    assert sync_get_auth() == \"sync-user:sync-pass\"\n    assert asyncio.run(async_get_auth()) == \"async-user:async-pass\"\n</code></pre>"},{"location":"concepts/#dependencies","title":"Dependencies","text":"<p>A dependency is (almost) any Python type or class required by a function.</p>"},{"location":"concepts/#built-in-types","title":"Built-In Types","text":"<p>PyBooster does not allow you to use built-in types directly. Instead you should use <code>NewType</code> to define a distinct subtype so that it is easily identifiable. For example, instead of using <code>str</code> to represent a username, you might define a <code>Username</code> new type like this:</p> <pre><code>from typing import NewType\n\nUsername = NewType(\"Username\", str)\n</code></pre> <p>Now you can make a provider for <code>Username</code> and inject it into functions.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nUsername = NewType(\"Username\", str)\n\n\n@provider.function\ndef username_provider() -&gt; Username:\n    return \"alice\"\n\n\n@injector.function\ndef get_message(*, username: Username = required) -&gt; str:\n    return f\"Hello, {username}!\"\n\n\nwith solution(username_provider):\n    assert get_message() == \"Hello, alice!\"\n</code></pre>"},{"location":"concepts/#user-defined-types","title":"User-Defined Types","text":"<p>This includes types you or a third-party package define. In this case, an <code>Auth</code> class:</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n\n@dataclass\nclass Auth:\n    role: str\n    username: str\n    password: str\n\n\n@provider.function\ndef auth_provider() -&gt; Auth:\n    return Auth(role=\"user\", username=\"alice\", password=\"EGwVEo3y9E\")\n\n\n@injector.function\ndef get_login_message(*, auth: Auth = required) -&gt; str:\n    return f\"Logged in as {auth.username}\"\n\n\nwith solution(auth_provider):\n    assert get_login_message() == \"Logged in as alice\"\n</code></pre>"},{"location":"concepts/#subclassed-types","title":"Subclassed Types","text":"<p>Providers of subclasses will be automatically injected into functions that require the base class. So an <code>AdminAuth</code> class that inherits from <code>Auth</code> can be injected into functions that require <code>Auth</code>.</p> <pre><code>from dataclasses import dataclass\nfrom dataclasses import field\nfrom typing import Literal\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n\n@dataclass\nclass Auth:\n    role: str\n    username: str\n    password: str\n\n\n@dataclass\nclass AdminAuth(Auth):\n    role: Literal[\"admin\"] = field(init=False, default=\"admin\")\n\n\n@provider.function\ndef admin_auth_provider() -&gt; AdminAuth:\n    return AdminAuth(username=\"admin\", password=\"admin\")\n\n\n@injector.function\ndef get_login_message(*, auth: Auth = required) -&gt; str:\n    return f\"Logged in as {auth.username}\"\n\n\nwith solution(admin_auth_provider):\n    assert get_login_message() == \"Logged in as admin\"\n</code></pre>"},{"location":"concepts/#tuple-types","title":"Tuple Types","text":"<p>You can provide a tuple of types from a provider in order to supply multiple dependencies at once. This can be useful if you need to destructure some value into separate dependencies.</p> <pre><code>import json\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nUsername = NewType(\"Username\", str)\nPassword = NewType(\"Password\", str)\n\ntempfile = NamedTemporaryFile()\nsecrets_json = Path(tempfile.name)\nsecrets_json.write_text('{\"username\": \"alice\", \"password\": \"EGwVEo3y9E\"}')\n\n\n@provider.function\ndef username_and_password_provider() -&gt; tuple[Username, Password]:\n    with secrets_json.open() as f:\n        secrets = json.load(f)\n    return Username(secrets[\"username\"]), Password(secrets[\"password\"])\n\n\n@injector.function\ndef get_login_message(*, username: Username = required) -&gt; str:\n    return f\"Logged in as {username}\"\n\n\nwith solution(username_and_password_provider):\n    assert get_login_message() == \"Logged in as alice\"\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#boto3","title":"Boto3","text":"<pre><code>import json\nfrom dataclasses import asdict\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING\nfrom typing import Annotated\nfrom typing import NewType\n\nfrom boto3.session import Session\nfrom botocore.client import BaseClient\nfrom moto import mock_aws\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n# Avoid importing mypy_boto3_s3 but still make S3Client available at runtime.\nif TYPE_CHECKING:\n    from mypy_boto3_s3 import S3Client\nelse:\n    S3Client = Annotated[BaseClient, \"mypy_boto3_s3.S3Client\"]\n\n\nBucketName = NewType(\"BucketName\", str)\n\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\n\n@provider.function\ndef client_provider(\n    service_name: str, *, session: Session = required\n) -&gt; BaseClient:\n    return session.client(service_name)\n\n\n@provider.function\ndef bucket_provider(\n    bucket_name: str, *, client: S3Client = required\n) -&gt; BucketName:\n    try:\n        # Check if the bucket already exists\n        client.head_bucket(Bucket=bucket_name)\n    except client.exceptions.ClientError as e:\n        # Create if it doesn't\n        if e.response[\"Error\"][\"Code\"] == \"404\":\n            client.create_bucket(Bucket=bucket_name)\n        else:\n            raise\n    return BucketName(bucket_name)\n\n\n@injector.function\ndef put_user(\n    user: User,\n    *,\n    bucket_name: BucketName = required,\n    client: S3Client = required,\n) -&gt; None:\n    data = json.dumps(asdict(user)).encode()\n    client.put_object(Bucket=bucket_name, Key=f\"user/{user.id}\", Body=data)\n\n\n@injector.function\ndef get_user(\n    user_id: int,\n    *,\n    bucket_name: BucketName = required,\n    client: S3Client = required,\n) -&gt; User:\n    response = client.get_object(Bucket=bucket_name, Key=f\"user/{user_id}\")\n    return User(**json.loads(response[\"Body\"].read()))\n\n\ndef main():\n    with mock_aws():  # Mock AWS services for testing purposes\n        with (\n            solution(\n                provider.singleton(Session, Session()),\n                client_provider[S3Client].bind(\"s3\"),\n                bucket_provider.bind(\"my-bucket\"),\n            ),\n            injector.current(BucketName),\n        ):\n            user = User(id=1, name=\"Alice\")\n            put_user(user)\n            assert get_user(user.id) == user\n\n\nmain()\n</code></pre>"},{"location":"examples/#starlette-sqlalchemy","title":"Starlette + SQLAlchemy","text":"<pre><code>import asyncio\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\n\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\nfrom starlette.testclient import TestClient\n\nfrom pybooster import injector\nfrom pybooster import required\nfrom pybooster import solution\nfrom pybooster.extra.asgi import PyBoosterMiddleware\nfrom pybooster.extra.sqlalchemy import async_engine_provider\nfrom pybooster.extra.sqlalchemy import async_session_provider\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column()\n\n\nDB_URL = \"sqlite+aiosqlite:///:memory:\"\n\n\n@asynccontextmanager\nasync def sqlalchemy_lifespan(_: Starlette) -&gt; AsyncIterator[None]:\n    with solution(async_engine_provider.bind(DB_URL), async_session_provider):\n        async with injector.current(AsyncEngine) as engine:\n            async with engine.begin() as conn:\n                await conn.run_sync(Base.metadata.create_all)\n            yield\n\n\n@injector.asyncfunction\nasync def post_user(\n    request: Request, *, session: AsyncSession = required\n) -&gt; JSONResponse:\n    async with session.begin():\n        user = User(**(await request.json()))\n        session.add(user)\n        await session.flush()\n        return JSONResponse({\"id\": user.id})\n\n\n@injector.asyncfunction\nasync def get_user(\n    request: Request, *, session: AsyncSession = required\n) -&gt; JSONResponse:\n    user = await session.get(User, request.path_params[\"id\"])\n    return JSONResponse(\n        None if user is None else {\"id\": user.id, \"name\": user.name}\n    )\n\n\napp = Starlette(\n    routes=[\n        Route(\"/user\", post_user, methods=[\"POST\"]),\n        Route(\"/user/{id:int}\", get_user, methods=[\"GET\"]),\n    ],\n    lifespan=sqlalchemy_lifespan,\n    middleware=[Middleware(PyBoosterMiddleware)],\n)\n\n\nasync def main():\n    with TestClient(app) as client:\n        response = client.post(\"/user\", json={\"name\": \"Alice\"})\n        assert response.status_code == 200\n        assert response.json() == {\"id\": 1}\n\n        response = client.get(\"/user/1\")\n        assert response.status_code == 200\n        assert response.json() == {\"id\": 1, \"name\": \"Alice\"}\n\n        response = client.get(\"/user/2\")\n        assert response.status_code == 200\n        assert response.json() is None\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/#sqlalchemy","title":"SQLAlchemy","text":"<pre><code>from sqlalchemy import Engine\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.orm import mapped_column\n\nfrom pybooster import injector\nfrom pybooster import required\nfrom pybooster import solution\nfrom pybooster.extra.sqlalchemy import engine_provider\nfrom pybooster.extra.sqlalchemy import session_provider\n\n\nclass Base(DeclarativeBase): ...\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n\n@injector.function\ndef create_tables(*, session: Session = required) -&gt; None:\n    Base.metadata.create_all(session.bind)\n\n\n@injector.function\ndef add_user(name: str, *, session: Session = required) -&gt; int:\n    with session.begin():\n        user = User(name=name)\n        session.add(user)\n        session.flush()\n        return user.id\n\n\n@injector.function\ndef get_user(user_id: int, *, session: Session = required) -&gt; User:\n    return session.execute(select(User).where(User.id == user_id)).scalar_one()\n\n\ndef main():\n    url = \"sqlite:///:memory:\"\n    with (\n        solution(\n            engine_provider.bind(url),\n            session_provider.bind(expire_on_commit=False),\n        ),\n        injector.current(Engine),\n    ):\n        create_tables()\n        user_id = add_user(\"Alice\")\n        user = get_user(user_id)\n        assert user.name == \"Alice\"\n\n\nmain()\n</code></pre>"},{"location":"examples/#sqlalchemy-async","title":"SQLAlchemy (Async)","text":"<pre><code>import asyncio\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nfrom pybooster import injector\nfrom pybooster import required\nfrom pybooster import solution\nfrom pybooster.extra.sqlalchemy import async_engine_provider\nfrom pybooster.extra.sqlalchemy import async_session_provider\n\n\nclass Base(DeclarativeBase): ...\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n\n@injector.asyncfunction\nasync def create_tables(*, engine: AsyncEngine = required) -&gt; None:\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n\n@injector.asyncfunction\nasync def add_user(name: str, *, session: AsyncSession = required) -&gt; int:\n    async with session.begin():\n        user = User(name=name)\n        session.add(user)\n        await session.flush()\n        return user.id\n\n\n@injector.asyncfunction\nasync def get_user(user_id: int, *, session: AsyncSession = required) -&gt; User:\n    return (\n        await session.execute(select(User).where(User.id == user_id))\n    ).scalar_one()\n\n\nasync def main():\n    url = \"sqlite+aiosqlite:///:memory:\"\n    with solution(\n        async_engine_provider.bind(url),\n        async_session_provider.bind(expire_on_commit=False),\n    ):\n        async with injector.current(AsyncEngine):\n            await create_tables()\n            user_id = await add_user(\"Alice\")\n            user = await get_user(user_id)\n            assert user.name == \"Alice\"\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/#sqlite","title":"SQLite","text":"<p>Shows how to create and read back a user from an SQLite database.</p> <pre><code>import sqlite3\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n\n\n@injector.function\ndef make_user_table(*, conn: sqlite3.Connection = required) -&gt; None:\n    conn.execute(\"CREATE TABLE user (id INTEGER PRIMARY KEY, name TEXT)\")\n    conn.commit()\n\n\nclass User:\n    def __init__(self, user_id: int, name: str):\n        self.id = user_id\n        self.name = name\n\n    @injector.function\n    def save(self, *, conn: sqlite3.Connection = required) -&gt; None:\n        conn.execute(\n            \"INSERT INTO user (id, name) VALUES (?, ?)\", (self.id, self.name)\n        )\n\n    @classmethod\n    @injector.function\n    def load(cls, user_id: int, *, conn: sqlite3.Connection = required) -&gt; Self:\n        cursor = conn.execute(\"SELECT name FROM user WHERE id = ?\", (user_id,))\n        name = cursor.fetchone()[0]\n        return cls(user_id, name)\n\n\ndef main():\n    with (\n        solution(sqlite_connection.bind(\":memory:\")),\n        # Reusing the same connection is only needed for in-memory databases.\n        injector.current(sqlite3.Connection),\n    ):\n        make_user_table()\n        user = User(1, \"Alice\")\n        user.save()\n        assert User.load(1).name == \"Alice\"\n\n\nmain()\n</code></pre>"},{"location":"integrations/","title":"Integrations","text":"<p>PyBooster supplies implementations for a number of popular tools and libraries.</p>"},{"location":"integrations/#asgi-apps","title":"ASGI Apps","text":"<p>PyBooster's use of <code>contextvars</code> under the hood can cause problems when state should live for the lifespan of an ASGI application. However this can be solved with a middleware provided by PyBooster. All you'll need to do is either wrap your ASGI application in it or pass it to your chosen framework's middleware system.</p> <pre><code>from pybooster.extra.asgi import PyBoosterMiddleware\n\nyour_app = ...\napp = PyBoosterMiddleware(your_app)\n</code></pre> <p>See the Starlette + SQLAlchemy example for one way to use this middleware.</p>"},{"location":"integrations/#sqlalchemy","title":"SQLAlchemy","text":"<p>PyBooster's SQLAlchemy integration supplies providers for the following dependencies:</p> Provider Dependency <code>pybooster.extra.sqlalchemy.engine_provider</code> <code>Engine</code> <code>pybooster.extra.sqlalchemy.session_provider</code> <code>Session</code> <code>pybooster.extra.sqlalchemy.async_engine_provider</code> <code>AsyncEngine</code> <code>pybooster.extra.sqlalchemy.async_session_provider</code> <code>AsyncSession</code> <p>The sync and async session providers are generic on their first positional argument which allows session subclasses to be used as dependencies instead. For example:</p> <pre><code>from sqlalchemy.orm import Session\n\nfrom pybooster.extra.sqlalchemy import session_provider\n\n\nclass MySession(Session): ...\n\n\nmy_session_provider = session_provider.bind(MySession)\n</code></pre> <p>See the Starlette + SQLAlchemy example for one way to use these providers.</p>"},{"location":"recipes/","title":"Recipes","text":""},{"location":"recipes/#side-effects","title":"Side Effects","text":"<p>To create a provider that does not yield a value but which has side effects create a subtype of <code>None</code> with the <code>NewType</code> function from the <code>typing</code> module. This new subtype can then be used as a dependency.</p> <pre><code>from typing import Iterator\nfrom typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import solution\n\nSwitchOn = NewType(\"SwitchOn\", None)\n\n\nSWITCH = False\n\n\n@provider.iterator\ndef switch_on() -&gt; Iterator[SwitchOn]:\n    global SWITCH\n    SWITCH = True\n    try:\n        yield\n    finally:\n        SWITCH = False\n\n\n@injector.function\ndef is_switch_on(*, _: SwitchOn = required) -&gt; bool:\n    return SWITCH\n\n\nwith solution(switch_on):\n    assert not SWITCH\n    assert is_switch_on()\n    assert not SWITCH\n</code></pre>"},{"location":"recipes/#calling-providers-directly","title":"Calling Providers Directly","text":"<p>Providers can be called directly as normal context managers with no additional effects.</p> <pre><code>from typing import NewType\n\nfrom pybooster import provider\n\nTheAnswer = NewType(\"TheAnswer\", int)\n\n\n@provider.function\ndef answer_provider() -&gt; TheAnswer:\n    return TheAnswer(42)\n\n\nwith answer_provider() as value:\n    assert value == 42\n</code></pre> <p>This can allow you to compose provider implementations without requiring them as a dependency. For example, you could create a SQLAlchemy transaction provider by wrapping a call to the <code>session_provider</code>:</p> <pre><code>from collections.abc import Iterator\nfrom typing import NewType\n\nfrom sqlalchemy.orm import Session\n\nfrom pybooster import provider\nfrom pybooster.extra.sqlalchemy import session_provider\n\nTransaction = NewType(\"Transaction\", Session)\n\n\n@provider.iterator\ndef transaction_provider() -&gt; Iterator[Transaction]:\n    with session_provider() as session, session.begin():\n        yield session\n</code></pre>"},{"location":"recipes/#testing-injected-functions","title":"Testing Injected Functions","text":""},{"location":"recipes/#testing-providers","title":"Testing Providers","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pybooster","title":"pybooster","text":""},{"location":"reference/#pybooster.required","title":"pybooster.required","text":"<pre><code>required = make_sentinel_value(__name__, 'required')\n</code></pre> <p>A sentinel object used to indicate that a dependency is required.</p>"},{"location":"reference/#pybooster.solution","title":"pybooster.solution","text":"<pre><code>solution(\n    *providers: Provider[[], Any]\n    | Sequence[Provider[[], Any]]\n) -&gt; Iterator[None]\n</code></pre> <p>Resolve the dependencies between the given providers and use them for the duration of the context.</p> Source code in <code>src/pybooster/core/solution.py</code> <pre><code>@contextmanager\ndef solution(*providers: Provider[[], Any] | Sequence[Provider[[], Any]]) -&gt; Iterator[None]:\n    \"\"\"Resolve the dependencies between the given providers and use them for the duration of the context.\"\"\"\n    sync_infos: dict[type, SyncProviderInfo] = {}\n    async_infos: dict[type, AsyncProviderInfo] = {}\n    for p in _normalize_providers(providers):\n        if isinstance(p, SyncProvider):\n            sync_infos.update(get_provider_info(p.producer, p.provides, p.dependencies, is_sync=True))\n        else:\n            async_infos.update(get_provider_info(p.producer, p.provides, p.dependencies, is_sync=False))\n    reset = set_solutions(sync_infos, async_infos)\n    try:\n        yield\n    finally:\n        reset()\n</code></pre>"},{"location":"reference/#pybooster.core","title":"pybooster.core","text":""},{"location":"reference/#pybooster.core.injector","title":"pybooster.core.injector","text":""},{"location":"reference/#pybooster.core.injector.required","title":"pybooster.core.injector.required","text":"<pre><code>required = make_sentinel_value(__name__, 'required')\n</code></pre> <p>A sentinel object used to indicate that a dependency is required.</p>"},{"location":"reference/#pybooster.core.injector.asynccontextmanager","title":"pybooster.core.injector.asynccontextmanager","text":"<pre><code>asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]\n</code></pre> <p>Inject dependencies into the given async context manager function.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]:\n    \"\"\"Inject dependencies into the given async context manager function.\"\"\"\n    return _asynccontextmanager(asynciterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.core.injector.asyncfunction","title":"pybooster.core.injector.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; Callable[P, Coroutine[Any, Any, R]]\n</code></pre> <p>Inject dependencies into the given coroutine.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; Callable[P, Coroutine[Any, Any, R]]:\n    \"\"\"Inject dependencies into the given coroutine.\"\"\"\n    required_params = get_required_parameters(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # type: ignore[reportReturnType]\n        stack = AsyncFastStack()\n        try:\n            await async_inject_keywords(stack, required_params, kwargs)\n            return await func(*args, **kwargs)\n        finally:\n            await stack.aclose()\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.core.injector.asynciterator","title":"pybooster.core.injector.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; AsyncIteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given async iterator.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; AsyncIteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given async iterator.\"\"\"\n    required_params = get_required_parameters(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        stack = AsyncFastStack()\n        try:\n            await async_inject_keywords(stack, required_params, kwargs)\n            async for value in func(*args, **kwargs):\n                yield value\n        finally:\n            await stack.aclose()\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.core.injector.contextmanager","title":"pybooster.core.injector.contextmanager","text":"<pre><code>contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; Callable[P, AbstractContextManager[R]]\n</code></pre> <p>Inject dependencies into the given context manager function.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; Callable[P, AbstractContextManager[R]]:\n    \"\"\"Inject dependencies into the given context manager function.\"\"\"\n    return _contextmanager(iterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.core.injector.current","title":"pybooster.core.injector.current","text":"<pre><code>current(cls: type[R]) -&gt; _CurrentContext[R]\n</code></pre> <p>Get the current value of a dependency.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>def current(cls: type[R]) -&gt; _CurrentContext[R]:\n    \"\"\"Get the current value of a dependency.\"\"\"\n    return _CurrentContext(cls)\n</code></pre>"},{"location":"reference/#pybooster.core.injector.function","title":"pybooster.core.injector.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; Callable[P, R]\n</code></pre> <p>Inject dependencies into the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to inject dependencies into.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies to inject into the function. Otherwise infered from function signature.</p> <code>None</code> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; Callable[P, R]:\n    \"\"\"Inject dependencies into the given function.\n\n    Args:\n        func: The function to inject dependencies into.\n        dependencies: The dependencies to inject into the function. Otherwise infered from function signature.\n    \"\"\"\n    required_params = get_required_parameters(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        stack = FastStack()\n        try:\n            sync_inject_keywords(stack, required_params, kwargs)\n            return func(*args, **kwargs)\n        finally:\n            stack.close()\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.core.injector.iterator","title":"pybooster.core.injector.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; IteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given iterator.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; IteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given iterator.\"\"\"\n    required_params = get_required_parameters(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        stack = FastStack()\n        try:\n            sync_inject_keywords(stack, required_params, kwargs)\n            yield from func(*args, **kwargs)\n        finally:\n            stack.close()\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.core.injector.overwrite","title":"pybooster.core.injector.overwrite","text":"<pre><code>overwrite(values: Mapping[type, Any]) -&gt; _OverwriteContext\n</code></pre> <p>Overwrite the current values of the given dependencies.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>def overwrite(values: Mapping[type, Any]) -&gt; _OverwriteContext:\n    \"\"\"Overwrite the current values of the given dependencies.\"\"\"\n    return _OverwriteContext(values)\n</code></pre>"},{"location":"reference/#pybooster.core.provider","title":"pybooster.core.provider","text":""},{"location":"reference/#pybooster.core.provider.Provider","title":"pybooster.core.provider.Provider","text":"<pre><code>Provider: TypeAlias = (\n    \"SyncProvider[P, R] | AsyncProvider[P, R]\"\n)\n</code></pre> <p>A provider for a dependency.</p>"},{"location":"reference/#pybooster.core.provider.AsyncProvider","title":"pybooster.core.provider.AsyncProvider","text":"<pre><code>AsyncProvider(\n    producer: AsyncContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: HintMap,\n)\n</code></pre> <p>               Bases: <code>Generic[P, R]</code>, <code>_BaseProvider[R]</code></p> <p>A provider for a dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __init__(\n    self,\n    producer: AsyncContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: HintMap,\n) -&gt; None:\n    self.producer = producer\n    self.provides = provides\n    self.dependencies = dependencies\n</code></pre>"},{"location":"reference/#pybooster.core.provider.AsyncProvider.bind","title":"pybooster.core.provider.AsyncProvider.bind","text":"<pre><code>bind(\n    *args: args, **kwargs: kwargs\n) -&gt; AsyncProvider[[], R]\n</code></pre> <p>Inject the dependencies and produce the dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def bind(self, *args: P.args, **kwargs: P.kwargs) -&gt; AsyncProvider[[], R]:\n    \"\"\"Inject the dependencies and produce the dependency.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#pybooster.core.provider.SyncProvider","title":"pybooster.core.provider.SyncProvider","text":"<pre><code>SyncProvider(\n    producer: ContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: HintMap,\n)\n</code></pre> <p>               Bases: <code>Generic[P, R]</code>, <code>_BaseProvider[R]</code></p> <p>A provider for a dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __init__(\n    self,\n    producer: ContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: HintMap,\n) -&gt; None:\n    self.producer = producer\n    self.provides = provides\n    self.dependencies = dependencies\n</code></pre>"},{"location":"reference/#pybooster.core.provider.SyncProvider.bind","title":"pybooster.core.provider.SyncProvider.bind","text":"<pre><code>bind(*args: args, **kwargs: kwargs) -&gt; SyncProvider[[], R]\n</code></pre> <p>Inject the dependencies and produce the dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def bind(self, *args: P.args, **kwargs: P.kwargs) -&gt; SyncProvider[[], R]:\n    \"\"\"Inject the dependencies and produce the dependency.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#pybooster.core.provider.asyncfunction","title":"pybooster.core.provider.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: HintMap | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given coroutine.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, Awaitable[R]]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: HintMap | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given coroutine.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_coroutine_return_type(func)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        yield await func(*args, **kwargs)\n\n    return asynciterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.core.provider.asynciterator","title":"pybooster.core.provider.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given async iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AsyncIteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given async iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=False)\n    dependencies = get_required_parameters(func, dependencies)\n    return AsyncProvider(\n        (injector.asynccontextmanager(func, dependencies=dependencies) if dependencies else _asynccontextmanager(func)),\n        cast(type[R], provides),\n        dependencies,\n    )\n</code></pre>"},{"location":"reference/#pybooster.core.provider.function","title":"pybooster.core.provider.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_callable_return_type(func)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        yield func(*args, **kwargs)\n\n    return iterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.core.provider.iterator","title":"pybooster.core.provider.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>IteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=True)\n    dependencies = get_required_parameters(func, dependencies)\n    return SyncProvider(\n        injector.contextmanager(func, dependencies=dependencies) if dependencies else _contextmanager(func),\n        cast(type[R], provides),\n        dependencies,\n    )\n</code></pre>"},{"location":"reference/#pybooster.core.provider.singleton","title":"pybooster.core.provider.singleton","text":"<pre><code>singleton(\n    provides: type[R] | Callable[[G], R], value: R | G\n) -&gt; SyncProvider[[], Any]\n</code></pre> <p>Create a provider for a singleton value.</p> <p>Parameters:</p> Name Type Description Default <code>provides</code> <code>type[R] | Callable[[G], R]</code> <p>The type that the value provides.</p> required <code>value</code> <code>R | G</code> <p>The value to provide</p> required Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def singleton(provides: type[R] | Callable[[G], R], value: R | G) -&gt; SyncProvider[[], Any]:\n    \"\"\"Create a provider for a singleton value.\n\n    Args:\n        provides: The type that the value provides.\n        value: The value to provide\n    \"\"\"\n    if isinstance(provides, type):\n\n        def get_value() -&gt; R:\n            return value  # type: ignore[reportReturnType]\n\n    else:\n\n        def get_value() -&gt; R:\n            return provides(value)  # type: ignore[reportArgumentType]\n\n    return function(provides=cast(type, provides))(get_value)\n</code></pre>"},{"location":"reference/#pybooster.core.solution","title":"pybooster.core.solution","text":""},{"location":"reference/#pybooster.core.solution.solution","title":"pybooster.core.solution.solution","text":"<pre><code>solution(\n    *providers: Provider[[], Any]\n    | Sequence[Provider[[], Any]]\n) -&gt; Iterator[None]\n</code></pre> <p>Resolve the dependencies between the given providers and use them for the duration of the context.</p> Source code in <code>src/pybooster/core/solution.py</code> <pre><code>@contextmanager\ndef solution(*providers: Provider[[], Any] | Sequence[Provider[[], Any]]) -&gt; Iterator[None]:\n    \"\"\"Resolve the dependencies between the given providers and use them for the duration of the context.\"\"\"\n    sync_infos: dict[type, SyncProviderInfo] = {}\n    async_infos: dict[type, AsyncProviderInfo] = {}\n    for p in _normalize_providers(providers):\n        if isinstance(p, SyncProvider):\n            sync_infos.update(get_provider_info(p.producer, p.provides, p.dependencies, is_sync=True))\n        else:\n            async_infos.update(get_provider_info(p.producer, p.provides, p.dependencies, is_sync=False))\n    reset = set_solutions(sync_infos, async_infos)\n    try:\n        yield\n    finally:\n        reset()\n</code></pre>"},{"location":"reference/#pybooster.core.state","title":"pybooster.core.state","text":""},{"location":"reference/#pybooster.core.state.copy_state","title":"pybooster.core.state.copy_state","text":"<pre><code>copy_state() -&gt; Callable[[], None]\n</code></pre> <p>Copy PyBooster's current state and return a callback that will set it in another context.</p> Source code in <code>src/pybooster/core/state.py</code> <pre><code>def copy_state() -&gt; Callable[[], None]:\n    \"\"\"Copy PyBooster's current state and return a callback that will set it in another context.\"\"\"\n    current_values = _CURRENT_VALUES.get()\n    full_solution = _FULL_SOLUTION.get()\n    sync_solution = _SYNC_SOLUTION.get()\n\n    def set_state() -&gt; None:\n        _CURRENT_VALUES.set(current_values)\n        _FULL_SOLUTION.set(full_solution)\n        _SYNC_SOLUTION.set(sync_solution)\n\n    return set_state\n</code></pre>"},{"location":"reference/#pybooster.extra","title":"pybooster.extra","text":""},{"location":"reference/#pybooster.extra.asgi","title":"pybooster.extra.asgi","text":""},{"location":"reference/#pybooster.extra.asgi.PyBoosterMiddleware","title":"pybooster.extra.asgi.PyBoosterMiddleware","text":"<pre><code>PyBoosterMiddleware(app: Asgi)\n</code></pre> <p>ASGI middleware to manage PyBooster's internal state.</p> Source code in <code>src/pybooster/extra/asgi.py</code> <pre><code>def __init__(self, app: Asgi) -&gt; None:\n    self.app = app\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy","title":"pybooster.extra.sqlalchemy","text":""},{"location":"reference/#pybooster.extra.sqlalchemy.async_session_provider","title":"pybooster.extra.sqlalchemy.async_session_provider","text":"<pre><code>async_session_provider = asynciterator(\n    _async_session_provider,\n    dependencies={\"bind\": AsyncEngine},\n    provides=_infer_async_session_type,\n)\n</code></pre> <p>Provide an async SQLAlchemy session.</p>"},{"location":"reference/#pybooster.extra.sqlalchemy.session_provider","title":"pybooster.extra.sqlalchemy.session_provider","text":"<pre><code>session_provider = iterator(\n    _session_provider,\n    dependencies={\"bind\": Engine},\n    provides=_infer_session_type,\n)\n</code></pre> <p>Provide a SQLAlchemy session.</p>"},{"location":"reference/#pybooster.extra.sqlalchemy.AsyncSessionMaker","title":"pybooster.extra.sqlalchemy.AsyncSessionMaker","text":"<p>               Bases: <code>Protocol[P, A_co]</code></p> <p>A protocol for creating an async SQLAlchemy session.</p>"},{"location":"reference/#pybooster.extra.sqlalchemy.AsyncSessionMaker.__call__","title":"pybooster.extra.sqlalchemy.AsyncSessionMaker.__call__","text":"<pre><code>__call__(\n    bind: AsyncEngine = ..., *args: args, **kwargs: kwargs\n) -&gt; A_co\n</code></pre> <p>Create an async SQLAlchemy session.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>def __call__(self, bind: AsyncEngine = ..., *args: P.args, **kwargs: P.kwargs) -&gt; A_co:\n    \"\"\"Create an async SQLAlchemy session.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy.SessionMaker","title":"pybooster.extra.sqlalchemy.SessionMaker","text":"<p>               Bases: <code>Protocol[P, S_co]</code></p> <p>A protocol for creating a SQLAlchemy session.</p>"},{"location":"reference/#pybooster.extra.sqlalchemy.SessionMaker.__call__","title":"pybooster.extra.sqlalchemy.SessionMaker.__call__","text":"<pre><code>__call__(\n    bind: Engine = ..., *args: args, **kwargs: kwargs\n) -&gt; S_co\n</code></pre> <p>Create a SQLAlchemy session.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>def __call__(self, bind: Engine = ..., *args: P.args, **kwargs: P.kwargs) -&gt; S_co:\n    \"\"\"Create a SQLAlchemy session.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy.async_engine_provider","title":"pybooster.extra.sqlalchemy.async_engine_provider","text":"<pre><code>async_engine_provider(\n    *args: Any, **kwargs: Any\n) -&gt; AsyncIterator[AsyncEngine]\n</code></pre> <p>Provide an async SQLAlchemy engine.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>@provider.asynciterator\n@copy_signature(create_async_engine)\nasync def async_engine_provider(*args: Any, **kwargs: Any) -&gt; AsyncIterator[AsyncEngine]:\n    \"\"\"Provide an async SQLAlchemy engine.\"\"\"\n    engine = create_async_engine(*args, **kwargs)\n    try:\n        yield engine\n    finally:\n        await engine.dispose()\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy.engine_provider","title":"pybooster.extra.sqlalchemy.engine_provider","text":"<pre><code>engine_provider(\n    *args: Any, **kwargs: Any\n) -&gt; Iterator[Engine]\n</code></pre> <p>Provide a SQLAlchemy engine.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>@provider.iterator\n@copy_signature(create_engine)\ndef engine_provider(*args: Any, **kwargs: Any) -&gt; Iterator[Engine]:\n    \"\"\"Provide a SQLAlchemy engine.\"\"\"\n    engine = create_engine(*args, **kwargs)\n    try:\n        yield engine\n    finally:\n        engine.dispose()\n</code></pre>"},{"location":"reference/#pybooster.injector","title":"pybooster.injector","text":""},{"location":"reference/#pybooster.injector.required","title":"pybooster.injector.required","text":"<pre><code>required = make_sentinel_value(__name__, 'required')\n</code></pre> <p>A sentinel object used to indicate that a dependency is required.</p>"},{"location":"reference/#pybooster.injector.asynccontextmanager","title":"pybooster.injector.asynccontextmanager","text":"<pre><code>asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]\n</code></pre> <p>Inject dependencies into the given async context manager function.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]:\n    \"\"\"Inject dependencies into the given async context manager function.\"\"\"\n    return _asynccontextmanager(asynciterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.injector.asyncfunction","title":"pybooster.injector.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; Callable[P, Coroutine[Any, Any, R]]\n</code></pre> <p>Inject dependencies into the given coroutine.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; Callable[P, Coroutine[Any, Any, R]]:\n    \"\"\"Inject dependencies into the given coroutine.\"\"\"\n    required_params = get_required_parameters(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # type: ignore[reportReturnType]\n        stack = AsyncFastStack()\n        try:\n            await async_inject_keywords(stack, required_params, kwargs)\n            return await func(*args, **kwargs)\n        finally:\n            await stack.aclose()\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.asynciterator","title":"pybooster.injector.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; AsyncIteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given async iterator.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; AsyncIteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given async iterator.\"\"\"\n    required_params = get_required_parameters(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        stack = AsyncFastStack()\n        try:\n            await async_inject_keywords(stack, required_params, kwargs)\n            async for value in func(*args, **kwargs):\n                yield value\n        finally:\n            await stack.aclose()\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.contextmanager","title":"pybooster.injector.contextmanager","text":"<pre><code>contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; Callable[P, AbstractContextManager[R]]\n</code></pre> <p>Inject dependencies into the given context manager function.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; Callable[P, AbstractContextManager[R]]:\n    \"\"\"Inject dependencies into the given context manager function.\"\"\"\n    return _contextmanager(iterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.injector.current","title":"pybooster.injector.current","text":"<pre><code>current(cls: type[R]) -&gt; _CurrentContext[R]\n</code></pre> <p>Get the current value of a dependency.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>def current(cls: type[R]) -&gt; _CurrentContext[R]:\n    \"\"\"Get the current value of a dependency.\"\"\"\n    return _CurrentContext(cls)\n</code></pre>"},{"location":"reference/#pybooster.injector.function","title":"pybooster.injector.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; Callable[P, R]\n</code></pre> <p>Inject dependencies into the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to inject dependencies into.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies to inject into the function. Otherwise infered from function signature.</p> <code>None</code> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; Callable[P, R]:\n    \"\"\"Inject dependencies into the given function.\n\n    Args:\n        func: The function to inject dependencies into.\n        dependencies: The dependencies to inject into the function. Otherwise infered from function signature.\n    \"\"\"\n    required_params = get_required_parameters(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        stack = FastStack()\n        try:\n            sync_inject_keywords(stack, required_params, kwargs)\n            return func(*args, **kwargs)\n        finally:\n            stack.close()\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.iterator","title":"pybooster.injector.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None\n) -&gt; IteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given iterator.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n) -&gt; IteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given iterator.\"\"\"\n    required_params = get_required_parameters(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        stack = FastStack()\n        try:\n            sync_inject_keywords(stack, required_params, kwargs)\n            yield from func(*args, **kwargs)\n        finally:\n            stack.close()\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.overwrite","title":"pybooster.injector.overwrite","text":"<pre><code>overwrite(values: Mapping[type, Any]) -&gt; _OverwriteContext\n</code></pre> <p>Overwrite the current values of the given dependencies.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>def overwrite(values: Mapping[type, Any]) -&gt; _OverwriteContext:\n    \"\"\"Overwrite the current values of the given dependencies.\"\"\"\n    return _OverwriteContext(values)\n</code></pre>"},{"location":"reference/#pybooster.provider","title":"pybooster.provider","text":""},{"location":"reference/#pybooster.provider.Provider","title":"pybooster.provider.Provider","text":"<pre><code>Provider: TypeAlias = (\n    \"SyncProvider[P, R] | AsyncProvider[P, R]\"\n)\n</code></pre> <p>A provider for a dependency.</p>"},{"location":"reference/#pybooster.provider.AsyncProvider","title":"pybooster.provider.AsyncProvider","text":"<pre><code>AsyncProvider(\n    producer: AsyncContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: HintMap,\n)\n</code></pre> <p>               Bases: <code>Generic[P, R]</code>, <code>_BaseProvider[R]</code></p> <p>A provider for a dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __init__(\n    self,\n    producer: AsyncContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: HintMap,\n) -&gt; None:\n    self.producer = producer\n    self.provides = provides\n    self.dependencies = dependencies\n</code></pre>"},{"location":"reference/#pybooster.provider.AsyncProvider.bind","title":"pybooster.provider.AsyncProvider.bind","text":"<pre><code>bind(\n    *args: args, **kwargs: kwargs\n) -&gt; AsyncProvider[[], R]\n</code></pre> <p>Inject the dependencies and produce the dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def bind(self, *args: P.args, **kwargs: P.kwargs) -&gt; AsyncProvider[[], R]:\n    \"\"\"Inject the dependencies and produce the dependency.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#pybooster.provider.SyncProvider","title":"pybooster.provider.SyncProvider","text":"<pre><code>SyncProvider(\n    producer: ContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: HintMap,\n)\n</code></pre> <p>               Bases: <code>Generic[P, R]</code>, <code>_BaseProvider[R]</code></p> <p>A provider for a dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __init__(\n    self,\n    producer: ContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: HintMap,\n) -&gt; None:\n    self.producer = producer\n    self.provides = provides\n    self.dependencies = dependencies\n</code></pre>"},{"location":"reference/#pybooster.provider.SyncProvider.bind","title":"pybooster.provider.SyncProvider.bind","text":"<pre><code>bind(*args: args, **kwargs: kwargs) -&gt; SyncProvider[[], R]\n</code></pre> <p>Inject the dependencies and produce the dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def bind(self, *args: P.args, **kwargs: P.kwargs) -&gt; SyncProvider[[], R]:\n    \"\"\"Inject the dependencies and produce the dependency.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#pybooster.provider.asyncfunction","title":"pybooster.provider.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: HintMap | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given coroutine.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, Awaitable[R]]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: HintMap | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given coroutine.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_coroutine_return_type(func)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        yield await func(*args, **kwargs)\n\n    return asynciterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.provider.asynciterator","title":"pybooster.provider.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given async iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AsyncIteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given async iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=False)\n    dependencies = get_required_parameters(func, dependencies)\n    return AsyncProvider(\n        (injector.asynccontextmanager(func, dependencies=dependencies) if dependencies else _asynccontextmanager(func)),\n        cast(type[R], provides),\n        dependencies,\n    )\n</code></pre>"},{"location":"reference/#pybooster.provider.function","title":"pybooster.provider.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_callable_return_type(func)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        yield func(*args, **kwargs)\n\n    return iterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.provider.iterator","title":"pybooster.provider.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>IteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>HintMap | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: HintMap | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=True)\n    dependencies = get_required_parameters(func, dependencies)\n    return SyncProvider(\n        injector.contextmanager(func, dependencies=dependencies) if dependencies else _contextmanager(func),\n        cast(type[R], provides),\n        dependencies,\n    )\n</code></pre>"},{"location":"reference/#pybooster.provider.singleton","title":"pybooster.provider.singleton","text":"<pre><code>singleton(\n    provides: type[R] | Callable[[G], R], value: R | G\n) -&gt; SyncProvider[[], Any]\n</code></pre> <p>Create a provider for a singleton value.</p> <p>Parameters:</p> Name Type Description Default <code>provides</code> <code>type[R] | Callable[[G], R]</code> <p>The type that the value provides.</p> required <code>value</code> <code>R | G</code> <p>The value to provide</p> required Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def singleton(provides: type[R] | Callable[[G], R], value: R | G) -&gt; SyncProvider[[], Any]:\n    \"\"\"Create a provider for a singleton value.\n\n    Args:\n        provides: The type that the value provides.\n        value: The value to provide\n    \"\"\"\n    if isinstance(provides, type):\n\n        def get_value() -&gt; R:\n            return value  # type: ignore[reportReturnType]\n\n    else:\n\n        def get_value() -&gt; R:\n            return provides(value)  # type: ignore[reportArgumentType]\n\n    return function(provides=cast(type, provides))(get_value)\n</code></pre>"},{"location":"reference/#pybooster.types","title":"pybooster.types","text":""},{"location":"reference/#pybooster.types.AnyContextManagerCallable","title":"pybooster.types.AnyContextManagerCallable","text":"<pre><code>AnyContextManagerCallable = Callable[\n    P,\n    AbstractContextManager[R]\n    | AbstractAsyncContextManager[R],\n]\n</code></pre> <p>A callable that returns any kind of context manager.</p>"},{"location":"reference/#pybooster.types.AsyncContextManagerCallable","title":"pybooster.types.AsyncContextManagerCallable","text":"<pre><code>AsyncContextManagerCallable = Callable[\n    P, AbstractAsyncContextManager[R]\n]\n</code></pre> <p>A callable that returns an async context manager.</p>"},{"location":"reference/#pybooster.types.AsyncIteratorCallable","title":"pybooster.types.AsyncIteratorCallable","text":"<pre><code>AsyncIteratorCallable = Callable[P, AsyncIterator[R]]\n</code></pre> <p>A callable that returns an async iterator.</p>"},{"location":"reference/#pybooster.types.ContextManagerCallable","title":"pybooster.types.ContextManagerCallable","text":"<pre><code>ContextManagerCallable = Callable[\n    P, AbstractContextManager[R]\n]\n</code></pre> <p>A callable that returns a context manager.</p>"},{"location":"reference/#pybooster.types.HintDict","title":"pybooster.types.HintDict","text":"<pre><code>HintDict = dict[str, type]\n</code></pre> <p>A dictionary of parameter or attribute names to their possible type or types.</p>"},{"location":"reference/#pybooster.types.HintMap","title":"pybooster.types.HintMap","text":"<pre><code>HintMap = Mapping[str, type]\n</code></pre> <p>A mapping of parameter or attribute names to their possible type or types.</p>"},{"location":"reference/#pybooster.types.IteratorCallable","title":"pybooster.types.IteratorCallable","text":"<pre><code>IteratorCallable = Callable[P, Iterator[R]]\n</code></pre> <p>A callable that returns an iterator.</p>"},{"location":"reference/#pybooster.types.InjectionError","title":"pybooster.types.InjectionError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>An error raised when an injection fails.</p>"},{"location":"reference/#pybooster.types.SolutionError","title":"pybooster.types.SolutionError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>An error raised when a solution fails.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial will guide you through the process of creating a \"To-Do\" application using PyBooster to facilitate access to various services and resources. The application will include a basic UI built using HTMX as well as a FastAPI server that's able to create, read, update, and delete tasks that support file attachments.</p> <pre><code>architecture-beta\n    service client(internet)[Client]\n    service db(database)[Database]\n    service storage(disk)[Storage]\n    service server(server)[Server]\n    junction serverRight1\n    junction serverRight2\n\n    client:R --&gt; L:server\n    server:R -- L:serverRight1\n    serverRight1:R -- L:serverRight2\n    serverRight1:B --&gt; T:db\n    serverRight2:B --&gt; T:storage</code></pre>"}]}