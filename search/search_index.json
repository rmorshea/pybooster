{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyBooster","text":"<p>Dependency injection without the boilerplate.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install -U pybooster\n</code></pre>"},{"location":"#at-a-glance","title":"At a Glance","text":"<p>Getting started with PyBooster involves a few steps:</p> <ol> <li>Define a provider function for a    dependency.</li> <li>Add an injector to a function that will use that dependency.</li> <li>Enter the provider's scope and call the dependent    function in it.</li> </ol> <p>The example below injects a <code>sqlite3.Connection</code> into a function that executes a query:</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n\n\n@injector.function\ndef query_database(query: str, *, conn: sqlite3.Connection = required) -&gt; None:\n    conn.execute(query)\n\n\nwith sqlite_connection.scope(\":memory:\"):\n    query_database(\"CREATE TABLE example (id INTEGER PRIMARY KEY)\")\n</code></pre> <p>This works by inspecting the type hints of the provider <code>sqlite_connection</code> to see that it produces a <code>sqlite3.Connection</code>. Simarly, the signature of the dependant function <code>query_database</code> is inspected to see that it requires a <code>sqlite3.Connection</code>. At that point, when <code>query_database</code> is called it checks to see if there's a <code>sqlite3.Connection</code> provider in scope and, if so, injects it into the function.</p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#injectors","title":"Injectors","text":"<p>Injectors are used to supply a set of dependencies to a function or context.</p>"},{"location":"concepts/#decorator-injectors","title":"Decorator Injectors","text":"<p>PyBooster supplies a set of decorators that can be added to functions in order to inject dependencies. Dependencies for a decorated function are declared as keyword-only arguments with a type annotation and a default value of <code>required</code>.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import required\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@injector.function\ndef hello_greeting(*, recipient: Recipient = required) -&gt; str:\n    return f\"Hello, {recipient}!\"\n</code></pre> <p>Warning</p> <p>Don't forget to add the <code>required</code> default value. Without it, PyBooster will not know that the argument is a dependency that needs to be injected.</p> <p>In order for a value to be injected you'll need to declare a provider and activate it's scope before calling the function.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@injector.function\ndef hello_greeting(*, recipient: Recipient = required) -&gt; str:\n    return f\"Hello, {recipient}!\"\n\n\n@provider.function\ndef alice() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\nwith alice.scope():\n    assert hello_greeting() == \"Hello, Alice!\"\n</code></pre> <p>PyBooster supports decorators for the following types of functions:</p> <ul> <li><code>injector.function</code></li> <li><code>injector.asyncfunction</code></li> <li><code>injector.iterator</code></li> <li><code>injector.asynciterator</code></li> <li><code>injector.contextmanager</code></li> <li><code>injector.asynccontextmanager</code></li> </ul> <p>You can use all of these decorators on methods of a class as well.</p> <p>Tip</p> <p>You can always skip injecting a dependency by passing a value directly as an argument:</p> <pre><code>assert hello_greeting(recipient=\"Bob\") == \"Hello, Bob!\"\n</code></pre> <p>This will not trigger the provider for <code>Recipient</code> and will use the value passed to the function instead. Doing so can be useful for re-using a dependency across multiple function calls without the indirection created by establishing a <code>shared context or value</code> .</p>"},{"location":"concepts/#inline-injector","title":"Inline Injector","text":"<p>If you need to access the current value of a dependency outside of a function, you can use <code>injector.current</code> by activating it either as a synchronous or asynchronous context manager.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef alice() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\nwith alice.scope(), injector.current(Recipient) as recipient:\n    assert recipient == \"Alice\"\n</code></pre>"},{"location":"concepts/#providers","title":"Providers","text":"<p>A provider is a function that creates or yields a dependency. Providers are used to define how dependencies resolved when they are injected into a function or context. What providers are available depends on what scopes are active when a dependency is resolved.</p>"},{"location":"concepts/#sync-providers","title":"Sync Providers","text":"<p>Sync providers can either be functions the return a dependency's value:</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import provider\n\n\n@dataclass\nclass Config:\n    app_name: str\n    app_version: int\n    debug_mode: bool\n\n\n@provider.function\ndef config() -&gt; Config:\n    return Config(app_name=\"MyApp\", app_version=1, debug_mode=True)\n</code></pre> <p>Or iterators that yield the dependency's value. Iterators are useful when you have resources that need to be cleaned up when the dependency's value is no longer in use.</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import provider\n\n\n@provider.iterator\ndef sqlite_connection() -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(\"example.db\") as conn:\n        yield conn\n</code></pre>"},{"location":"concepts/#async-providers","title":"Async Providers","text":"<p>Async providers can either be a coroutine function that returns a dependency's value:</p> <pre><code>from asyncio import sleep\nfrom dataclasses import dataclass\n\nfrom pybooster import provider\n\n\n@dataclass\nclass Config:\n    app_name: str\n    app_version: int\n    debug_mode: bool\n\n\n@provider.asyncfunction\nasync def async_config() -&gt; Config:\n    await sleep(1)  # Do some async work here...\n    return Config(app_name=\"MyApp\", app_version=1, debug_mode=True)\n</code></pre> <p>Or async iterators that yield the dependency's value. Async iterators are useful when you have resources that need to be cleaned up when the dependency's value is no longer in use.</p> <pre><code>from asyncio import StreamReader\nfrom asyncio import open_connection\nfrom typing import AsyncIterator\n\nfrom pybooster import provider\n\n\n@provider.asynciterator\nasync def example_reader() -&gt; AsyncIterator[StreamReader]:\n    reader, writer = await open_connection(\"example.com\", 80)\n    writer.write(b\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\")\n    await writer.drain()\n    try:\n        yield reader\n    finally:\n        writer.close()\n        await writer.wait_closed()\n</code></pre>"},{"location":"concepts/#generic-providers","title":"Generic Providers","text":"<p>You can use a single provider to supply multiple dependencies by narrowing the return type if it's a base class, union, <code>Any</code>, or includes a <code>TypeVar</code>. This is done using square brackets to annotate the exact concrete type that the provider will supply before activating its scope. So, in the case you have a provider that loads json data from a file you could annotate its return type as <code>Any</code> but narrow the type to <code>ConfigDict</code> before entering its scope.</p> <pre><code>import json\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import Any\nfrom typing import TypedDict\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@provider.function\ndef load_json(path: str | Path) -&gt; Any:\n    with Path(path).open() as f:\n        return json.load(f)\n\n\nclass ConfigDict(TypedDict):\n    app_name: str\n    app_version: int\n    debug_mode: bool\n\n\n@injector.function\ndef get_config(*, config: ConfigDict = required) -&gt; ConfigDict:\n    return config\n\n\ntempfile = NamedTemporaryFile()\nconfig_json = Path(tempfile.name)\nconfig_json.write_text('{\"app_name\": \"MyApp\", \"app_version\": 1, \"debug_mode\": true}')\n\nwith load_json[ConfigDict].scope(config_json):\n    assert get_config() == {\"app_name\": \"MyApp\", \"app_version\": 1, \"debug_mode\": True}\n</code></pre> <p>Since concrete types for <code>TypeVar</code>s cannot be automatically inferred from the arguments passed to the provider. You must always narrow the return type (as shown above) or pass a <code>provides</code> inference function to the <code>@provider</code> decorator to specify how to figure out the concrete type. This function should can take all the non-dependency arguments of the provider and return the concrete type. In the example below the provider is generic on the <code>cls: type[T]</code> argument so the <code>provides</code> inference function will just return that:</p> <pre><code>import json\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import TypeVar\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Config:\n    app_name: str\n    app_version: int\n    debug_mode: bool\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\nT = TypeVar(\"T\")\n\n\n@provider.function(provides=lambda cls, *a, **kw: cls)\ndef config_from_file(cls: type[T], path: str | Path) -&gt; T:\n    with Path(path).open() as f:\n        return cls(**json.load(f))\n\n\n@injector.function\ndef get_config(*, config: Config = required) -&gt; Config:\n    return config\n\n\ntempfile = NamedTemporaryFile()\nconfig_json = Path(tempfile.name)\nconfig_json.write_text('{\"app_name\": \"MyApp\", \"app_version\": 1, \"debug_mode\": true}')\n\nwith config_from_file.scope(Config, config_json):\n    assert get_config() == Config(app_name=\"MyApp\", app_version=1, debug_mode=True)\n</code></pre> <p>Tip</p> <p>This approach also works great for a provider that has <code>overload</code> implementations.</p>"},{"location":"concepts/#parameterizing-providers","title":"Parameterizing Providers","text":"<p>You can pass additional arguments to a provider by adding parameters to a provider function signature that are not dependencies:</p> <pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import provider\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n</code></pre> <p>These parameters can be supplied when activating the <code>scope</code>.</p> <pre><code>with sqlite_connection.scope(\":memory:\"):\n    ...\n</code></pre> <p>You can also declare these parameters as dependencies by making them keyword-only, annotating them with the desired type, and setting the default value to <code>required</code>.</p> <pre><code>import os\nimport sqlite3\nfrom typing import Iterator\nfrom typing import NewType\n\nfrom pybooster import provider\nfrom pybooster import required\n\nDatabase = NewType(\"DatabasePath\", str)\n\n\n@provider.function\ndef sqlite_database() -&gt; Database:\n    return Database(os.environ.get(\"SQLITE_DATABASE\", \":memory:\"))\n\n\n@provider.iterator\ndef sqlite_connection(*, database: Database = required) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n</code></pre>"},{"location":"concepts/#scoping-providers","title":"Scoping Providers","text":"<p>What providers are available to inject dependencies is determined by what scopes are active when the dependency is resolved. Scopes can be activated using the <code>scope</code> method of a provider.</p> <pre><code>from typing import NewType\n\nfrom pybooster import provider\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef alice() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\nwith alice.scope():\n    ...  # alice is available to inject\n</code></pre> <p>You can override a dependency's provider by activating a new scope for the same dependency.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\nRecipient = NewType(\"Recipient\", str)\n\n\n@provider.function\ndef alice() -&gt; Recipient:\n    return Recipient(\"Alice\")\n\n\n@provider.function\ndef bob() -&gt; Recipient:\n    return Recipient(\"Bob\")\n\n\n@injector.function\ndef get_recipient(*, recipient: Recipient = required) -&gt; str:\n    return recipient\n\n\nwith alice.scope():\n    assert get_recipient() == \"Alice\"\n    with bob.scope():\n        assert get_recipient() == \"Bob\"\n    assert get_recipient() == \"Alice\"\n</code></pre> <p>Info</p> <p>The exact behavior of scopes can depend on whether the requested dependency is a union or has subclasses. Refer to those sections for more information.</p>"},{"location":"concepts/#mixing-syncasync","title":"Mixing Sync/Async","text":"<p>You can define both sync and async providers for the same dependency. Sync providers can be used in async contexts, but not the other way around. PyBooster will always choose to use an async provider when running in an async context and one is available.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@provider.function\ndef sync_auth() -&gt; Auth:\n    return Auth(username=\"sync-user\", password=\"sync-pass\")\n\n\n@provider.asyncfunction\nasync def async_auth() -&gt; Auth:\n    await asyncio.sleep(0)  # Do some async work here...\n    return Auth(username=\"async-user\", password=\"async-pass\")\n\n\n@injector.function\ndef sync_get_auth(*, auth: Auth = required) -&gt; str:\n    return f\"{auth.username}:{auth.password}\"\n\n\n@injector.asyncfunction\nasync def get_async_auth(*, auth: Auth = required) -&gt; str:\n    return f\"{auth.username}:{auth.password}\"\n\n\nwith sync_auth.scope(), async_auth.scope():\n    assert sync_get_auth() == \"sync-user:sync-pass\"\n    assert asyncio.run(get_async_auth()) == \"async-user:async-pass\"\n\nwith sync_auth.scope():\n    assert asyncio.run(get_async_auth()) == \"sync-user:sync-pass\"\n</code></pre>"},{"location":"concepts/#dependencies","title":"Dependencies","text":"<p>A dependency is (almost) any Python type or class required by a function.</p>"},{"location":"concepts/#built-in-types","title":"Built-In Types","text":"<p>PyBooster does not allow you to use built-in types directly. Instead you should use <code>NewType</code> to define a distinct subtype so that it is easily identifiable. For example, instead of using <code>str</code> to represent a username, you might define a <code>Username</code> new type like this:</p> <pre><code>from typing import NewType\n\nUsername = NewType(\"Username\", str)\n</code></pre> <p>Now you can make a provider for <code>Username</code> and inject it into functions.</p> <pre><code>from typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\nUsername = NewType(\"Username\", str)\n\n\n@provider.function\ndef username() -&gt; Username:\n    return \"alice\"\n\n\n@injector.function\ndef greeting(*, username: Username = required) -&gt; str:\n    return f\"Hello, {username}!\"\n\n\nwith username.scope():\n    assert greeting() == \"Hello, alice!\"\n</code></pre>"},{"location":"concepts/#user-defined-types","title":"User-Defined Types","text":"<p>This includes types you or a third-party package define. In this case, an <code>Auth</code> class:</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Auth:\n    role: str\n    username: str\n    password: str\n\n\n@provider.function\ndef auth() -&gt; Auth:\n    return Auth(role=\"user\", username=\"alice\", password=\"EGwVEo3y9E\")\n\n\n@injector.function\ndef login_message(*, auth: Auth = required) -&gt; str:\n    return f\"Logged in as {auth.username}\"\n\n\nwith auth.scope():\n    assert login_message() == \"Logged in as alice\"\n</code></pre>"},{"location":"concepts/#subclassed-types","title":"Subclassed Types","text":"<p>Providers of subclasses will be automatically injected into functions that require the base class. So an <code>AdminAuth</code> class that inherits from <code>Auth</code> can be injected into functions that require <code>Auth</code>.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Literal\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Auth:\n    role: str\n    username: str\n    password: str\n\n\n@dataclass\nclass AdminAuth(Auth):\n    role: Literal[\"admin\"]\n\n\n@provider.function\ndef admin_auth() -&gt; AdminAuth:\n    return AdminAuth(role=\"admin\", username=\"admin\", password=\"admin\")\n\n\n@injector.function\ndef login_message(*, auth: Auth = required) -&gt; str:\n    return f\"Logged in as {auth.username}\"\n\n\nwith admin_auth.scope():\n    assert login_message() == \"Logged in as admin\"\n</code></pre>"},{"location":"concepts/#union-types","title":"Union Types","text":"<p>You can require a union of types by using the <code>Union</code> type or the <code>|</code> operator (where supported). Doing so will resolve the first dependency that has a provider available in the order declared by the union (left-to-right). This could be useful in case, as below, where you have an <code>Employee</code> or <code>Contractor</code> class that are not related by inheritance.</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@dataclass\nclass Employee:\n    name: str\n    employee_id: int\n\n\n@dataclass\nclass Contractor:\n    name: str\n    contractor_id: int\n\n\n@provider.function\ndef employee() -&gt; Employee:\n    return Employee(name=\"Alice\", employee_id=1)\n\n\n@provider.function\ndef contractor() -&gt; Contractor:\n    return Contractor(name=\"Bob\", contractor_id=2)\n\n\n@injector.function\ndef greet(*, person: Employee | Contractor = required) -&gt; str:\n    return f\"Hello, {person.name}!\"\n\n\nwith employee.scope():\n    assert greet() == \"Hello, Alice!\"\n\nwith contractor.scope():\n    assert greet() == \"Hello, Bob!\"\n\nwith employee.scope(), contractor.scope():\n    assert greet() == \"Hello, Alice!\"\n</code></pre>"},{"location":"concepts/#tuple-types","title":"Tuple Types","text":"<p>You can provide a tuple of types from a provider in order to provide multiple dependencies at once. This is useful in async or threaded providers when it would be more efficient to gather dependencies in parallel. Or, as in the case below, if you need to destructure some data into separate dependencies.</p> <pre><code>import json\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import NewType\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\nUsername = NewType(\"Username\", str)\nPassword = NewType(\"Password\", str)\n\ntempfile = NamedTemporaryFile()\nsecrets_json = Path(tempfile.name)\nsecrets_json.write_text('{\"username\": \"alice\", \"password\": \"EGwVEo3y9E\"}')\n\n\n@provider.function\ndef username_and_password() -&gt; tuple[Username, Password]:\n    with secrets_json.open() as f:\n        secrets = json.load(f)\n    return Username(secrets[\"username\"]), Password(secrets[\"password\"])\n\n\n@injector.function\ndef login_message(*, username: Username = required) -&gt; str:\n    return f\"Logged in as {username}\"\n\n\nwith username_and_password.scope():\n    assert login_message() == \"Logged in as alice\"\n</code></pre>"},{"location":"concepts/#sharing","title":"Sharing","text":"<p>PyBooster provides ways to share a dependency across multiple injections.</p>"},{"location":"concepts/#shared-contexts","title":"Shared Contexts","text":"<p>By default, PyBooster will create a new instance of a dependency each time it is injected. To change this, using the <code>shared</code> context manager to declare that a dependency should be re-used across all injections for the duration of a context. This will immediately execute the provider and store the result for future use.</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import shared\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@provider.function\ndef auth() -&gt; Auth:\n    return Auth(username=\"alice\", password=\"EGwVEo3y9E\")\n\n\n@injector.function\ndef get_auth(*, auth: Auth = required) -&gt; Auth:\n    return auth\n\n\nwith auth.scope():\n\n    assert get_auth() is not get_auth()\n\n    with shared(Auth):\n        assert get_auth() is get_auth()\n</code></pre> <p>Info</p> <p>If the dependency's provider is, or could be asynchronous, enter the <code>shared()</code> context manager using <code>async with</code> instead. This will ensure that async providers can be executed successfully. Even if the provider is synchronous, using <code>async with</code> will still work.</p>"},{"location":"concepts/#shared-values","title":"Shared Values","text":"<p>You can share a static value amongst injections and without needing a provider by passing a <code>value</code> argument to the <code>shared</code> context manager. This can be useful for sharing configuration values or other static data.</p> <pre><code>from dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import required\nfrom pybooster import shared\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@injector.function\ndef get_auth(*, auth: Auth = required) -&gt; Auth:\n    return auth\n\n\nwith shared(Auth, value=Auth(username=\"alice\", password=\"EGwVEo3y9E\")):\n    assert get_auth() is get_auth()\n</code></pre> <p>Using a shared value will also cause any providers for the dependency to be ignored.</p> <pre><code>import os\nfrom dataclasses import dataclass\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import shared\n\n\n@dataclass\nclass Auth:\n    username: str\n    password: str\n\n\n@provider.function\ndef auth_from_env() -&gt; Auth:\n    return Auth(username=os.environ[\"USERNAME\"], password=os.environ[\"PASSWORD\"])\n\n\n@injector.function\ndef get_auth(*, auth: Auth = required) -&gt; Auth:\n    return auth\n\n\nfake_auth = Auth(username=\"fake\", password=\"fake\")\nwith shared(Auth, value=fake_auth), auth_from_env.scope():\n    assert get_auth() == fake_auth\n</code></pre> <p>Note that if <code>auth_from_env</code> had gotten executed it would have raised a <code>KeyError</code> because <code>os.environ[\"USERNAME\"]</code> and <code>os.environ[\"PASSWORD\"]</code> would not have been set. However, because the <code>shared</code> context manager was used, the provider was skipped.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#boto3","title":"Boto3","text":"<pre><code>from boto3.session import Session\nfrom botocore.client import BaseClient\nfrom moto import mock_aws\nfrom mypy_boto3_s3 import S3Client\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\nfrom pybooster import shared\n\n\n@provider.function\ndef aws_client(service_name: str, *, session: Session = required) -&gt; BaseClient:\n    return session.client(service_name)\n\n\n@injector.function\ndef create_bucket(bucket_name: str, *, client: S3Client = required) -&gt; None:\n    client.create_bucket(Bucket=bucket_name)\n\n\n@injector.function\ndef list_buckets(*, client: S3Client = required) -&gt; list[str]:\n    return [bucket[\"Name\"] for bucket in client.list_buckets()[\"Buckets\"]]\n\n\ndef main():\n    with mock_aws():  # Mock AWS services for testing purposes\n        with shared(Session, value=Session()), aws_client[S3Client].scope(\"s3\"):\n            create_bucket(\"my-bucket\")\n            assert \"my-bucket\" in list_buckets()\n\n\nmain()\n</code></pre>"},{"location":"examples/#sqlalchemy","title":"SQLAlchemy","text":"<pre><code>from sqlalchemy import Engine\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.orm import mapped_column\n\nfrom pybooster import injector\nfrom pybooster import required\nfrom pybooster import shared\nfrom pybooster.extra.sqlalchemy import engine_provider\nfrom pybooster.extra.sqlalchemy import transaction_provider\n\n\nclass Base(DeclarativeBase): ...\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n\n@injector.function\ndef create_tables(*, session: Session = required) -&gt; None:\n    Base.metadata.create_all(session.bind)\n\n\n@injector.function\ndef add_user(name: str, *, session: Session = required) -&gt; int:\n    user = User(name=name)\n    session.add(user)\n    session.flush()\n    return user.id\n\n\n@injector.function\ndef get_user(user_id: int, *, session: Session = required) -&gt; User:\n    return session.execute(select(User).where(User.id == user_id)).scalar_one()\n\n\ndef main():\n    url = \"sqlite:///:memory:\"\n    with (\n        engine_provider.scope(url),\n        shared(Engine),\n        transaction_provider.scope(expire_on_commit=False),\n    ):\n        create_tables()\n        user_id = add_user(\"Alice\")\n        user = get_user(user_id)\n        assert user.name == \"Alice\"\n\n\nmain()\n</code></pre>"},{"location":"examples/#sqlalchemy-async","title":"SQLAlchemy (Async)","text":"<pre><code>import asyncio\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nfrom pybooster import injector\nfrom pybooster import required\nfrom pybooster import shared\nfrom pybooster.extra.sqlalchemy import async_engine_provider\nfrom pybooster.extra.sqlalchemy import async_transaction_provider\n\n\nclass Base(DeclarativeBase): ...\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n\n@injector.asyncfunction\nasync def create_tables(*, engine: AsyncEngine = required) -&gt; None:\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n\n@injector.asyncfunction\nasync def add_user(name: str, *, session: AsyncSession = required) -&gt; int:\n    user = User(name=name)\n    session.add(user)\n    await session.flush()\n    return user.id\n\n\n@injector.asyncfunction\nasync def get_user(user_id: int, *, session: AsyncSession = required) -&gt; User:\n    return (await session.execute(select(User).where(User.id == user_id))).scalar_one()\n\n\nasync def main():\n    url = \"sqlite+aiosqlite:///:memory:\"\n    with async_engine_provider.scope(url):\n        async with shared(AsyncEngine):\n            with async_transaction_provider.scope(expire_on_commit=False):\n                await create_tables()\n                user_id = await add_user(\"Alice\")\n                user = await get_user(user_id)\n                assert user.name == \"Alice\"\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/#sqlite","title":"SQLite","text":"<pre><code>import sqlite3\nfrom typing import Iterator\n\nfrom pybooster import injector\nfrom pybooster import provider\nfrom pybooster import required\n\n\n@provider.iterator\ndef sqlite_connection(database: str) -&gt; Iterator[sqlite3.Connection]:\n    with sqlite3.connect(database) as conn:\n        yield conn\n\n\n@injector.function\ndef query_database(query: str, *, conn: sqlite3.Connection = required) -&gt; None:\n    conn.execute(query)\n\n\ndef main():\n    with sqlite_connection.scope(\":memory:\"):\n        query_database(\"CREATE TABLE example (id INTEGER PRIMARY KEY)\")\n\n\nmain()\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pybooster","title":"pybooster","text":""},{"location":"reference/#pybooster.required","title":"pybooster.required","text":"<pre><code>required = make_sentinel_value(__name__, 'required')\n</code></pre> <p>A sentinel object used to indicate that a dependency is required.</p>"},{"location":"reference/#pybooster.shared","title":"pybooster.shared","text":"<pre><code>shared(\n    cls: type[R] | Sequence, value: R = undefined\n) -&gt; _SharedContext[R]\n</code></pre> <p>Declare that a single value should be shared across all injections of a dependency.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[R] | Sequence</code> <p>The dependency to share.</p> required <code>value</code> <code>R</code> <p>The value to share. If not provided, the dependency will be resolved.</p> <code>undefined</code> Source code in <code>src/pybooster/core/shared.py</code> <pre><code>def shared(cls: type[R] | Sequence, value: R = undefined) -&gt; _SharedContext[R]:\n    \"\"\"Declare that a single value should be shared across all injections of a dependency.\n\n    Args:\n        cls: The dependency to share.\n        value: The value to share. If not provided, the dependency will be resolved.\n    \"\"\"\n    return _SharedContext(normalize_dependency(cls), value=value)\n</code></pre>"},{"location":"reference/#pybooster.core","title":"pybooster.core","text":""},{"location":"reference/#pybooster.core.injector","title":"pybooster.core.injector","text":""},{"location":"reference/#pybooster.core.injector.asynccontextmanager","title":"pybooster.core.injector.asynccontextmanager","text":"<pre><code>asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]\n</code></pre> <p>Inject dependencies into the given async context manager function.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]:\n    \"\"\"Inject dependencies into the given async context manager function.\"\"\"\n    return _asynccontextmanager(asynciterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.core.injector.asyncfunction","title":"pybooster.core.injector.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, Coroutine[Any, Any, R]]\n</code></pre> <p>Inject dependencies into the given coroutine.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, Coroutine[Any, Any, R]]:\n    \"\"\"Inject dependencies into the given coroutine.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # type: ignore[reportReturnType]\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            return await func(*args, **kwargs)\n        async with AsyncExitStack() as stack:\n            await async_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            return await func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.core.injector.asynciterator","title":"pybooster.core.injector.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; AsyncIteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given async iterator.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; AsyncIteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given async iterator.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            async for value in func(*args, **kwargs):\n                yield value\n            return\n        async with AsyncExitStack() as stack:\n            await async_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            async for value in func(*args, **kwargs):\n                yield value\n            return\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.core.injector.contextmanager","title":"pybooster.core.injector.contextmanager","text":"<pre><code>contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, AbstractContextManager[R]]\n</code></pre> <p>Inject dependencies into the given context manager function.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, AbstractContextManager[R]]:\n    \"\"\"Inject dependencies into the given context manager function.\"\"\"\n    return _contextmanager(iterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.core.injector.current","title":"pybooster.core.injector.current","text":"<pre><code>current(cls: type[R]) -&gt; _CurrentContext[R]\n</code></pre> <p>Get the current value of a dependency.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>def current(cls: type[R]) -&gt; _CurrentContext[R]:\n    \"\"\"Get the current value of a dependency.\"\"\"\n    return _CurrentContext(normalize_dependency(cls))\n</code></pre>"},{"location":"reference/#pybooster.core.injector.function","title":"pybooster.core.injector.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, R]\n</code></pre> <p>Inject dependencies into the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to inject dependencies into.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies to inject into the function.</p> <code>None</code> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, R]:\n    \"\"\"Inject dependencies into the given function.\n\n    Args:\n        func: The function to inject dependencies into.\n        dependencies: The dependencies to inject into the function.\n    \"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            return func(*args, **kwargs)\n        with ExitStack() as stack:\n            sync_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.core.injector.iterator","title":"pybooster.core.injector.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; IteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given iterator.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; IteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given iterator.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        try:\n            if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n                yield from func(*args, **kwargs)\n                return\n            with ExitStack() as stack:\n                sync_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n                yield from func(*args, **kwargs)\n                return\n        except StopIteration as e:\n            return e.value  # noqa: B901\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.core.provider","title":"pybooster.core.provider","text":""},{"location":"reference/#pybooster.core.provider.Provider","title":"pybooster.core.provider.Provider","text":"<pre><code>Provider: TypeAlias = (\n    \"SyncProvider[P, R] | AsyncProvider[P, R]\"\n)\n</code></pre> <p>A provider that produces a dependency.</p>"},{"location":"reference/#pybooster.core.provider.AsyncProvider","title":"pybooster.core.provider.AsyncProvider","text":"<pre><code>AsyncProvider(\n    manager: AsyncContextManagerCallable[P, R],\n    provides: type[R],\n    dependencies: NormDependencies,\n)\n</code></pre> <p>               Bases: <code>_BaseProvider[P, R]</code></p> <p>A provider that produces an async dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __init__(\n    self,\n    manager: AsyncContextManagerCallable[P, R],\n    provides: type[R],\n    dependencies: NormDependencies,\n) -&gt; None:\n    super().__init__(manager, provides, dependencies, sync=False)\n    self.new = manager\n</code></pre>"},{"location":"reference/#pybooster.core.provider.AsyncProvider.__getitem__","title":"pybooster.core.provider.AsyncProvider.__getitem__","text":"<pre><code>__getitem__(provides: type[R]) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Declare a specific type for a generic provider.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __getitem__(self, provides: type[R]) -&gt; AsyncProvider[P, R]:\n    \"\"\"Declare a specific type for a generic provider.\"\"\"\n    return AsyncProvider(self.new, provides, self._dependencies)\n</code></pre>"},{"location":"reference/#pybooster.core.provider.SyncProvider","title":"pybooster.core.provider.SyncProvider","text":"<pre><code>SyncProvider(\n    manager: ContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: NormDependencies,\n)\n</code></pre> <p>               Bases: <code>_BaseProvider[P, R]</code></p> <p>A provider that produces a dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __init__(\n    self,\n    manager: ContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: NormDependencies,\n) -&gt; None:\n    super().__init__(manager, provides, dependencies, sync=True)\n    self.new = manager\n</code></pre>"},{"location":"reference/#pybooster.core.provider.SyncProvider.__getitem__","title":"pybooster.core.provider.SyncProvider.__getitem__","text":"<pre><code>__getitem__(provides: type[R]) -&gt; SyncProvider[P, R]\n</code></pre> <p>Declare a specific type for a generic provider.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __getitem__(self, provides: type[R]) -&gt; SyncProvider[P, R]:\n    \"\"\"Declare a specific type for a generic provider.\"\"\"\n    return SyncProvider(self.new, provides, self._dependencies)\n</code></pre>"},{"location":"reference/#pybooster.core.provider.asyncfunction","title":"pybooster.core.provider.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given coroutine.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, Awaitable[R]]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given coroutine.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_coroutine_return_type(func)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        yield await func(*args, **kwargs)\n\n    return asynciterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.core.provider.asynciterator","title":"pybooster.core.provider.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given async iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AsyncIteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given async iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=False)\n    norm_dependencies = get_callable_dependencies(func, dependencies)\n    return AsyncProvider(\n        (\n            injector.asynccontextmanager(func, dependencies=norm_dependencies)\n            if norm_dependencies\n            else _asynccontextmanager(func)\n        ),\n        cast(type[R], provides),\n        norm_dependencies,\n    )\n</code></pre>"},{"location":"reference/#pybooster.core.provider.function","title":"pybooster.core.provider.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_callable_return_type(func)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        yield func(*args, **kwargs)\n\n    return iterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.core.provider.iterator","title":"pybooster.core.provider.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>IteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=True)\n    norm_dependencies = get_callable_dependencies(func, dependencies)\n    return SyncProvider(\n        injector.contextmanager(func, dependencies=norm_dependencies) if norm_dependencies else _contextmanager(func),\n        cast(type[R], provides),\n        norm_dependencies,\n    )\n</code></pre>"},{"location":"reference/#pybooster.core.shared","title":"pybooster.core.shared","text":""},{"location":"reference/#pybooster.core.shared.shared","title":"pybooster.core.shared.shared","text":"<pre><code>shared(\n    cls: type[R] | Sequence, value: R = undefined\n) -&gt; _SharedContext[R]\n</code></pre> <p>Declare that a single value should be shared across all injections of a dependency.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[R] | Sequence</code> <p>The dependency to share.</p> required <code>value</code> <code>R</code> <p>The value to share. If not provided, the dependency will be resolved.</p> <code>undefined</code> Source code in <code>src/pybooster/core/shared.py</code> <pre><code>def shared(cls: type[R] | Sequence, value: R = undefined) -&gt; _SharedContext[R]:\n    \"\"\"Declare that a single value should be shared across all injections of a dependency.\n\n    Args:\n        cls: The dependency to share.\n        value: The value to share. If not provided, the dependency will be resolved.\n    \"\"\"\n    return _SharedContext(normalize_dependency(cls), value=value)\n</code></pre>"},{"location":"reference/#pybooster.core.types","title":"pybooster.core.types","text":""},{"location":"reference/#pybooster.core.types.AnyContextManagerCallable","title":"pybooster.core.types.AnyContextManagerCallable","text":"<pre><code>AnyContextManagerCallable = Callable[\n    P,\n    AbstractContextManager[R]\n    | AbstractAsyncContextManager[R],\n]\n</code></pre> <p>A callable that returns any kind of context manager.</p>"},{"location":"reference/#pybooster.core.types.AsyncContextManagerCallable","title":"pybooster.core.types.AsyncContextManagerCallable","text":"<pre><code>AsyncContextManagerCallable = Callable[\n    P, AbstractAsyncContextManager[R]\n]\n</code></pre> <p>A callable that returns an async context manager.</p>"},{"location":"reference/#pybooster.core.types.AsyncIteratorCallable","title":"pybooster.core.types.AsyncIteratorCallable","text":"<pre><code>AsyncIteratorCallable = Callable[P, AsyncIterator[R]]\n</code></pre> <p>A callable that returns an async iterator.</p>"},{"location":"reference/#pybooster.core.types.ContextManagerCallable","title":"pybooster.core.types.ContextManagerCallable","text":"<pre><code>ContextManagerCallable = Callable[\n    P, AbstractContextManager[R]\n]\n</code></pre> <p>A callable that returns a context manager.</p>"},{"location":"reference/#pybooster.core.types.Dependencies","title":"pybooster.core.types.Dependencies","text":"<pre><code>Dependencies = Mapping[str, type | Sequence[type]]\n</code></pre> <p>A mapping of parameter names to their possible type or types.</p>"},{"location":"reference/#pybooster.core.types.IteratorCallable","title":"pybooster.core.types.IteratorCallable","text":"<pre><code>IteratorCallable = Callable[P, Iterator[R]]\n</code></pre> <p>A callable that returns an iterator.</p>"},{"location":"reference/#pybooster.core.types.required","title":"pybooster.core.types.required","text":"<pre><code>required = make_sentinel_value(__name__, 'required')\n</code></pre> <p>A sentinel object used to indicate that a dependency is required.</p>"},{"location":"reference/#pybooster.core.types.ProviderMissingError","title":"pybooster.core.types.ProviderMissingError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>An error raised when a provider is missing.</p>"},{"location":"reference/#pybooster.extra","title":"pybooster.extra","text":""},{"location":"reference/#pybooster.extra.asgi","title":"pybooster.extra.asgi","text":""},{"location":"reference/#pybooster.extra.asgi.LifespanManager","title":"pybooster.extra.asgi.LifespanManager","text":"<pre><code>LifespanManager(\n    app: ASGI3Application,\n    *,\n    contexts: Sequence[\n        AnyContextManager, Callable[[], AnyContextManager]\n    ]\n)\n</code></pre> <p>An ASGI middleware the establishes context managers that are active for the lifespan of the application.</p> <p>Importantly it ensure context variables modified by those context managers are injected into request handlers.</p> Source code in <code>src/pybooster/extra/asgi.py</code> <pre><code>def __init__(\n    self,\n    app: ASGI3Application,\n    *,\n    contexts: Sequence[AnyContextManager, Callable[[], AnyContextManager]],\n):\n    self.app = app\n    self._app_state: _AppState | None = None\n    self._contexts = _make_context_manager_pairs(contexts)\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy","title":"pybooster.extra.sqlalchemy","text":""},{"location":"reference/#pybooster.extra.sqlalchemy.async_engine_provider","title":"pybooster.extra.sqlalchemy.async_engine_provider","text":"<pre><code>async_engine_provider(\n    *args: Any, **kwargs: Any\n) -&gt; AsyncIterator[AsyncEngine]\n</code></pre> <p>Provide a SQLAlchemy async engine.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>@provider.asynciterator\n@copy_signature(create_async_engine)\nasync def async_engine_provider(*args: Any, **kwargs: Any) -&gt; AsyncIterator[AsyncEngine]:\n    \"\"\"Provide a SQLAlchemy async engine.\"\"\"\n    engine = create_async_engine(*args, **kwargs)\n    try:\n        yield engine\n    finally:\n        await engine.dispose()\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy.async_session_provider","title":"pybooster.extra.sqlalchemy.async_session_provider","text":"<pre><code>async_session_provider(\n    *, bind: AsyncEngine = required, **kwargs: Any\n) -&gt; AsyncIterator[AsyncSession]\n</code></pre> <p>Provide a SQLAlchemy async session.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>@provider.asynciterator\n@copy_signature(AsyncSession)  # not entirely accurate since `bind` can be possitional\nasync def async_session_provider(*, bind: AsyncEngine = required, **kwargs: Any) -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"Provide a SQLAlchemy async session.\"\"\"\n    async with AsyncSession(bind, **kwargs) as session:\n        yield session\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy.async_transaction_provider","title":"pybooster.extra.sqlalchemy.async_transaction_provider","text":"<pre><code>async_transaction_provider(\n    *, bind: AsyncEngine = required, **kwargs: Any\n) -&gt; AsyncIterator[AsyncSession]\n</code></pre> <p>Provide a SQLAlchemy async session within a transaction.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>@provider.asynciterator\n@copy_signature(AsyncSession)  # not entirely accurate since `bind` can be possitional\nasync def async_transaction_provider(*, bind: AsyncEngine = required, **kwargs: Any) -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"Provide a SQLAlchemy async session within a transaction.\"\"\"\n    async with AsyncSession(bind, **kwargs) as session, session.begin():\n        yield session\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy.engine_provider","title":"pybooster.extra.sqlalchemy.engine_provider","text":"<pre><code>engine_provider(\n    *args: Any, **kwargs: Any\n) -&gt; Iterator[Engine]\n</code></pre> <p>Provide a SQLAlchemy engine.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>@provider.iterator\n@copy_signature(create_engine)\ndef engine_provider(*args: Any, **kwargs: Any) -&gt; Iterator[Engine]:\n    \"\"\"Provide a SQLAlchemy engine.\"\"\"\n    engine = create_engine(*args, **kwargs)\n    try:\n        yield engine\n    finally:\n        engine.dispose()\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy.session_provider","title":"pybooster.extra.sqlalchemy.session_provider","text":"<pre><code>session_provider(\n    *, bind: Engine = required, **kwargs: Any\n) -&gt; Iterator[Session]\n</code></pre> <p>Provide a SQLAlchemy session.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>@provider.iterator\n@copy_signature(Session)  # not entirely accurate since `bind` can be possitional\ndef session_provider(*, bind: Engine = required, **kwargs: Any) -&gt; Iterator[Session]:\n    \"\"\"Provide a SQLAlchemy session.\"\"\"\n    with Session(bind, **kwargs) as session:\n        yield session\n</code></pre>"},{"location":"reference/#pybooster.extra.sqlalchemy.transaction_provider","title":"pybooster.extra.sqlalchemy.transaction_provider","text":"<pre><code>transaction_provider(\n    *, bind: Engine = required, **kwargs: Any\n) -&gt; Iterator[Session]\n</code></pre> <p>Provide a SQLAlchemy session within a transaction.</p> Source code in <code>src/pybooster/extra/sqlalchemy.py</code> <pre><code>@provider.iterator\n@copy_signature(Session)  # not entirely accurate since `bind` can be possitional\ndef transaction_provider(*, bind: Engine = required, **kwargs: Any) -&gt; Iterator[Session]:\n    \"\"\"Provide a SQLAlchemy session within a transaction.\"\"\"\n    with Session(bind, **kwargs) as session, session.begin():\n        yield session\n</code></pre>"},{"location":"reference/#pybooster.injector","title":"pybooster.injector","text":""},{"location":"reference/#pybooster.injector.asynccontextmanager","title":"pybooster.injector.asynccontextmanager","text":"<pre><code>asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]\n</code></pre> <p>Inject dependencies into the given async context manager function.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asynccontextmanager(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, AbstractAsyncContextManager[R]]:\n    \"\"\"Inject dependencies into the given async context manager function.\"\"\"\n    return _asynccontextmanager(asynciterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.injector.asyncfunction","title":"pybooster.injector.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, Coroutine[Any, Any, R]]\n</code></pre> <p>Inject dependencies into the given coroutine.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Coroutine[Any, Any, R]],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, Coroutine[Any, Any, R]]:\n    \"\"\"Inject dependencies into the given coroutine.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # type: ignore[reportReturnType]\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            return await func(*args, **kwargs)\n        async with AsyncExitStack() as stack:\n            await async_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            return await func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.asynciterator","title":"pybooster.injector.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; AsyncIteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given async iterator.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; AsyncIteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given async iterator.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            async for value in func(*args, **kwargs):\n                yield value\n            return\n        async with AsyncExitStack() as stack:\n            await async_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            async for value in func(*args, **kwargs):\n                yield value\n            return\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.contextmanager","title":"pybooster.injector.contextmanager","text":"<pre><code>contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, AbstractContextManager[R]]\n</code></pre> <p>Inject dependencies into the given context manager function.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef contextmanager(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, AbstractContextManager[R]]:\n    \"\"\"Inject dependencies into the given context manager function.\"\"\"\n    return _contextmanager(iterator(func, dependencies=dependencies))\n</code></pre>"},{"location":"reference/#pybooster.injector.current","title":"pybooster.injector.current","text":"<pre><code>current(cls: type[R]) -&gt; _CurrentContext[R]\n</code></pre> <p>Get the current value of a dependency.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>def current(cls: type[R]) -&gt; _CurrentContext[R]:\n    \"\"\"Get the current value of a dependency.\"\"\"\n    return _CurrentContext(normalize_dependency(cls))\n</code></pre>"},{"location":"reference/#pybooster.injector.function","title":"pybooster.injector.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; Callable[P, R]\n</code></pre> <p>Inject dependencies into the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to inject dependencies into.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies to inject into the function.</p> <code>None</code> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; Callable[P, R]:\n    \"\"\"Inject dependencies into the given function.\n\n    Args:\n        func: The function to inject dependencies into.\n        dependencies: The dependencies to inject into the function.\n    \"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n            return func(*args, **kwargs)\n        with ExitStack() as stack:\n            sync_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n            return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.injector.iterator","title":"pybooster.injector.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None\n) -&gt; IteratorCallable[P, R]\n</code></pre> <p>Inject dependencies into the given iterator.</p> Source code in <code>src/pybooster/core/injector.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n) -&gt; IteratorCallable[P, R]:\n    \"\"\"Inject dependencies into the given iterator.\"\"\"\n    dependencies = get_callable_dependencies(func, dependencies)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        try:\n            if not (missing := setdefault_arguments_with_initialized_dependencies(kwargs, dependencies)):\n                yield from func(*args, **kwargs)\n                return\n            with ExitStack() as stack:\n                sync_update_arguments_by_initializing_dependencies(stack, kwargs, missing)\n                yield from func(*args, **kwargs)\n                return\n        except StopIteration as e:\n            return e.value  # noqa: B901\n\n    return wrapper\n</code></pre>"},{"location":"reference/#pybooster.provider","title":"pybooster.provider","text":""},{"location":"reference/#pybooster.provider.Provider","title":"pybooster.provider.Provider","text":"<pre><code>Provider: TypeAlias = (\n    \"SyncProvider[P, R] | AsyncProvider[P, R]\"\n)\n</code></pre> <p>A provider that produces a dependency.</p>"},{"location":"reference/#pybooster.provider.AsyncProvider","title":"pybooster.provider.AsyncProvider","text":"<pre><code>AsyncProvider(\n    manager: AsyncContextManagerCallable[P, R],\n    provides: type[R],\n    dependencies: NormDependencies,\n)\n</code></pre> <p>               Bases: <code>_BaseProvider[P, R]</code></p> <p>A provider that produces an async dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __init__(\n    self,\n    manager: AsyncContextManagerCallable[P, R],\n    provides: type[R],\n    dependencies: NormDependencies,\n) -&gt; None:\n    super().__init__(manager, provides, dependencies, sync=False)\n    self.new = manager\n</code></pre>"},{"location":"reference/#pybooster.provider.AsyncProvider.__getitem__","title":"pybooster.provider.AsyncProvider.__getitem__","text":"<pre><code>__getitem__(provides: type[R]) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Declare a specific type for a generic provider.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __getitem__(self, provides: type[R]) -&gt; AsyncProvider[P, R]:\n    \"\"\"Declare a specific type for a generic provider.\"\"\"\n    return AsyncProvider(self.new, provides, self._dependencies)\n</code></pre>"},{"location":"reference/#pybooster.provider.SyncProvider","title":"pybooster.provider.SyncProvider","text":"<pre><code>SyncProvider(\n    manager: ContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: NormDependencies,\n)\n</code></pre> <p>               Bases: <code>_BaseProvider[P, R]</code></p> <p>A provider that produces a dependency.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __init__(\n    self,\n    manager: ContextManagerCallable[P, R],\n    provides: type[R] | Callable[..., type[R]],\n    dependencies: NormDependencies,\n) -&gt; None:\n    super().__init__(manager, provides, dependencies, sync=True)\n    self.new = manager\n</code></pre>"},{"location":"reference/#pybooster.provider.SyncProvider.__getitem__","title":"pybooster.provider.SyncProvider.__getitem__","text":"<pre><code>__getitem__(provides: type[R]) -&gt; SyncProvider[P, R]\n</code></pre> <p>Declare a specific type for a generic provider.</p> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>def __getitem__(self, provides: type[R]) -&gt; SyncProvider[P, R]:\n    \"\"\"Declare a specific type for a generic provider.\"\"\"\n    return SyncProvider(self.new, provides, self._dependencies)\n</code></pre>"},{"location":"reference/#pybooster.provider.asyncfunction","title":"pybooster.provider.asyncfunction","text":"<pre><code>asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given coroutine.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, Awaitable[R]]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef asyncfunction(\n    func: Callable[P, Awaitable[R]],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given coroutine.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_coroutine_return_type(func)\n\n    @wraps(func)\n    async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; AsyncIterator[R]:\n        yield await func(*args, **kwargs)\n\n    return asynciterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.provider.asynciterator","title":"pybooster.provider.asynciterator","text":"<pre><code>asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; AsyncProvider[P, R]\n</code></pre> <p>Create a provider from the given async iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AsyncIteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef asynciterator(\n    func: AsyncIteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; AsyncProvider[P, R]:\n    \"\"\"Create a provider from the given async iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=False)\n    norm_dependencies = get_callable_dependencies(func, dependencies)\n    return AsyncProvider(\n        (\n            injector.asynccontextmanager(func, dependencies=norm_dependencies)\n            if norm_dependencies\n            else _asynccontextmanager(func)\n        ),\n        cast(type[R], provides),\n        norm_dependencies,\n    )\n</code></pre>"},{"location":"reference/#pybooster.provider.function","title":"pybooster.provider.function","text":"<pre><code>function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef function(\n    func: Callable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_callable_return_type(func)\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Iterator[R]:\n        yield func(*args, **kwargs)\n\n    return iterator(wrapper, provides=provides, dependencies=dependencies)\n</code></pre>"},{"location":"reference/#pybooster.provider.iterator","title":"pybooster.provider.iterator","text":"<pre><code>iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: (\n        type[R] | Callable[..., type[R]] | None\n    ) = None\n) -&gt; SyncProvider[P, R]\n</code></pre> <p>Create a provider from the given iterator function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>IteratorCallable[P, R]</code> <p>The function to create a provider from.</p> required <code>dependencies</code> <code>Dependencies | None</code> <p>The dependencies of the function (infered if not provided).</p> <code>None</code> <code>provides</code> <code>type[R] | Callable[..., type[R]] | None</code> <p>The type that the function provides (infered if not provided).</p> <code>None</code> Source code in <code>src/pybooster/core/provider.py</code> <pre><code>@paramorator\ndef iterator(\n    func: IteratorCallable[P, R],\n    *,\n    dependencies: Dependencies | None = None,\n    provides: type[R] | Callable[..., type[R]] | None = None,\n) -&gt; SyncProvider[P, R]:\n    \"\"\"Create a provider from the given iterator function.\n\n    Args:\n        func: The function to create a provider from.\n        dependencies: The dependencies of the function (infered if not provided).\n        provides: The type that the function provides (infered if not provided).\n    \"\"\"\n    provides = provides or get_iterator_yield_type(func, sync=True)\n    norm_dependencies = get_callable_dependencies(func, dependencies)\n    return SyncProvider(\n        injector.contextmanager(func, dependencies=norm_dependencies) if norm_dependencies else _contextmanager(func),\n        cast(type[R], provides),\n        norm_dependencies,\n    )\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial will guide you through the process of creating a \"To-Do\" application using PyBooster to facilitate access to various services and resources. The application will include a basic UI built using HTMX as well as a FastAPI server that's able to create, read, update, and delete tasks that support file attachments.</p> <pre><code>architecture-beta\n    service client(internet)[Client]\n    service db(database)[Database]\n    service storage(disk)[Storage]\n    service server(server)[Server]\n    junction serverRight1\n    junction serverRight2\n\n    client:R --&gt; L:server\n    server:R -- L:serverRight1\n    serverRight1:R -- L:serverRight2\n    serverRight1:B --&gt; T:db\n    serverRight2:B --&gt; T:storage</code></pre>"}]}